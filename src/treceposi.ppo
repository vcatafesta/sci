#line 12 "c:\sci\include\rddName.ch"
    EXTERNAL leto
    EXTERNAL DBFNTX
   EXTERNAL DBFCDX


    EXTERNAL DBFFPT
    EXTERNAL SIXCDX
    EXTERNAL DBFNSX
    EXTERNAL HB_MEMIO
#line 4 "treceposi.prg"
_HB_CLASS TWindow ; function TWindow ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TWindow", iif( .F., { }, { @HBObject() } ), @TWindow() ) ) ;

    _HB_MEMBER { hWnd, nOldProc } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hWnd", "nOldProc"}, .F. )
    _HB_MEMBER { AS LOGICAL lRegistered } ; oClass:AddMultiClsData( "LOGICAL",, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lRegistered"}, .F. )
oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TWindow ;

_HB_CLASS TReceposi ; function TReceposi ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TReceposi", iif( .F., { }, { @HBObject() } ), @TReceposi() ) ) ;

    _HB_MEMBER { cWho } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cWho"}, .F. )
    _HB_MEMBER { cNome } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cNome"}, .F. )
    _HB_MEMBER { aHistRecibo } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aHistRecibo"}, .F. )
    _HB_MEMBER { aUserRecibo } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aUserRecibo"}, .F. )
    _HB_MEMBER { aReciboImpresso } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aReciboImpresso"}, .F. )
    _HB_MEMBER { aAtivo } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aAtivo"}, .F. )
    _HB_MEMBER { aAtivoSwap } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aAtivoSwap"}, .F. )
   _HB_MEMBER { aRecno } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aRecno"}, .F. )
    _HB_MEMBER { aTodos } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aTodos"}, .F. )
    _HB_MEMBER { aCodi } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aCodi"}, .F. )
    _HB_MEMBER { alMulta } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"alMulta"}, .F. )
    _HB_MEMBER { xTodos } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"xTodos"}, .F. )
    _HB_MEMBER { aDataPag } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aDataPag"}, .F. )
    _HB_MEMBER { aRescisao } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aRescisao"}, .F. )

    _HB_MEMBER { aDocnr_Selecao_Imprimir } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aDocnr_Selecao_Imprimir"}, .F. )
    _HB_MEMBER { aSoma_Selecao_Imprimir } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aSoma_Selecao_Imprimir"}, .F. )
    _HB_MEMBER { aObs_Selecao_Imprimir } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aObs_Selecao_Imprimir"}, .F. )
    _HB_MEMBER { aCurElemento_Selecao } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aCurElemento_Selecao"}, .F. )
    _HB_MEMBER { nSoma_Total_Imprimir } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nSoma_Total_Imprimir"}, .F. )
    _HB_MEMBER { nPrincipalSelecao } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPrincipalSelecao"}, .F. )
    _HB_MEMBER { nJurosSelecao } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nJurosSelecao"}, .F. )
    _HB_MEMBER { nMultaSelecao } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMultaSelecao"}, .F. )
    _HB_MEMBER { nRescisaoSelecao } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRescisaoSelecao"}, .F. )

    _HB_MEMBER { nPrincipal_Vencer } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPrincipal_Vencer"}, .F. )
    _HB_MEMBER { nJuros_Vencer } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nJuros_Vencer"}, .F. )
    _HB_MEMBER { nMulta_Vencer } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMulta_Vencer"}, .F. )
    _HB_MEMBER { nTotal_Vencer } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTotal_Vencer"}, .F. )
    _HB_MEMBER { nQtdDoc_Vencer } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nQtdDoc_Vencer"}, .F. )

    _HB_MEMBER { nPrincipal_Rescisao } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPrincipal_Rescisao"}, .F. )
    _HB_MEMBER { nJuros_Rescisao } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nJuros_Rescisao"}, .F. )
    _HB_MEMBER { nMulta_Rescisao } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMulta_Rescisao"}, .F. )
    _HB_MEMBER { nTotal_Rescisao } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTotal_Rescisao"}, .F. )
    _HB_MEMBER { nQtdDoc_Rescisao } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nQtdDoc_Rescisao"}, .F. )

    _HB_MEMBER { CorVencido } ; oClass:AddMultiData(, AscanCor(16), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"CorVencido"}, .F. )
    _HB_MEMBER { CorAviso } ; oClass:AddMultiData(, AscanCor(15), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"CorAviso"}, .F. )
    _HB_MEMBER { CorDuplicado } ; oClass:AddMultiData(, AscanCor(14), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"CorDuplicado"}, .F. )
    _HB_MEMBER { CorRecibo } ; oClass:AddMultiData(, AscanCor(13), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"CorRecibo"}, .F. )
    _HB_MEMBER { CorDesativado } ; oClass:AddMultiData(, AscanCor(12), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"CorDesativado"}, .F. )
    _HB_MEMBER { CorVencer } ; oClass:AddMultiData(, AscanCor(11), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"CorVencer"}, .F. )
    _HB_MEMBER { CorSelecao } ; oClass:AddMultiData(, AscanCor(10), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"CorSelecao"}, .F. )
    _HB_MEMBER { CorAlterado } ; oClass:AddMultiData(, AscanCor(04), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"CorAlterado"}, .F. )
    _HB_MEMBER { nCorZebradoBranco } ; oClass:AddMultiData(, AscanCor(15), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nCorZebradoBranco"}, .F. )
    _HB_MEMBER { nCorZebradoVerde } ; oClass:AddMultiData(, AscanCor(14), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nCorZebradoVerde"}, .F. )

    _HB_MEMBER { nPrincipal_Vencido } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPrincipal_Vencido"}, .F. )
    _HB_MEMBER { nJuros_Vencido } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nJuros_Vencido"}, .F. )
    _HB_MEMBER { nMulta_Vencido } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMulta_Vencido"}, .F. )
    _HB_MEMBER { nTotal_Vencido } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTotal_Vencido"}, .F. )
    _HB_MEMBER { nQtdDoc_Vencido } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nQtdDoc_Vencido"}, .F. )

    _HB_MEMBER { nPrincipal_Recibo } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPrincipal_Recibo"}, .F. )
    _HB_MEMBER { nJuros_Recibo } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nJuros_Recibo"}, .F. )
    _HB_MEMBER { nMulta_Recibo } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMulta_Recibo"}, .F. )
    _HB_MEMBER { nTotal_Recibo } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTotal_Recibo"}, .F. )
    _HB_MEMBER { nQtdDoc_Recibo } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nQtdDoc_Recibo"}, .F. )

    _HB_MEMBER { nPrincipal_Geral } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPrincipal_Geral"}, .F. )
    _HB_MEMBER { nJuros_Geral } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nJuros_Geral"}, .F. )
    _HB_MEMBER { nMulta_Geral } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMulta_Geral"}, .F. )
    _HB_MEMBER { nTotal_Geral } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTotal_Geral"}, .F. )
    _HB_MEMBER { nQtdDoc_Geral } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nQtdDoc_Geral"}, .F. )

    _HB_MEMBER { nPrincipal } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPrincipal"}, .F. )
    _HB_MEMBER { nJurosPago } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nJurosPago"}, .F. )
    _HB_MEMBER { nRecebido } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRecebido"}, .F. )
    _HB_MEMBER { nAberto } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nAberto"}, .F. )
    _HB_MEMBER { nQtdDoc } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nQtdDoc"}, .F. )
    _HB_MEMBER { cStrSelecao } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cStrSelecao"}, .F. )
    _HB_MEMBER { cStrRecibo } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cStrRecibo"}, .F. )
    _HB_MEMBER { cStrVencido } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cStrVencido"}, .F. )
    _HB_MEMBER { cStrVencer } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cStrVencer"}, .F. )
    _HB_MEMBER { cStrGeral } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cStrGeral"}, .F. )
    _HB_MEMBER { Color_pFore } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Color_pFore"}, .F. )
    _HB_MEMBER { Color_pBack } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Color_pBack"}, .F. )
    _HB_MEMBER { Color_pUns } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Color_pUns"}, .F. )
    _HB_MEMBER { CurElemento } ; oClass:AddMultiData(, 1, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"CurElemento"}, .F. )
     _HB_MEMBER { nChoice } ; oClass:AddMultiData(, NIL, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nChoice"}, .F. )
    _HB_MEMBER { nOrdem } ; oClass:AddMultiData(, NIL, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nOrdem"}, .F. )
     _HB_MEMBER { xParam } ; oClass:AddMultiData(, NIL, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"xParam"}, .F. )
    _HB_MEMBER { cTop } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cTop"}, .F. )
    _HB_MEMBER { cBottom } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cBottom"}, .F. )
    _HB_MEMBER { aBottom } ; oClass:AddMultiData(, {"","", ""}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aBottom"}, .F. )

    _HB_MEMBER { nBoxRow } ; oClass:AddMultiData(, 8, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBoxRow"}, .F. )
    _HB_MEMBER { nBoxCol } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBoxCol"}, .F. )
    _HB_MEMBER { nBoxRow1 } ; oClass:AddMultiData(, ms_MaxRow()-1, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBoxRow1"}, .F. )
    _HB_MEMBER { nBoxCol1 } ; oClass:AddMultiData(, MaxCol(), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBoxCol1"}, .F. )

    _HB_MEMBER { nPrtRow } ; oClass:AddMultiData(, MaxRow(), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPrtRow"}, .F. )
    _HB_MEMBER { nPrtCol } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPrtCol"}, .F. )
    _HB_MEMBER { PosiAgeInd } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"PosiAgeInd"}, .F. )
    _HB_MEMBER { PosiAgeAll } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"PosiAgeAll"}, .F. )
    _HB_MEMBER { PosiReceber } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"PosiReceber"}, .F. )
   _HB_MEMBER { dIni } ; oClass:AddMultiData(, Ctod("01/01/91"), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"dIni"}, .F. )
   _HB_MEMBER { dFim } ; oClass:AddMultiData(, Ctod("31/12/" + Right(Dtoc(Date()),2)), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"dFim"}, .F. )
   _HB_MEMBER { dCalculo } ; oClass:AddMultiData(, Date(), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"dCalculo"}, .F. )
    _HB_MEMBER { lRescisao } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lRescisao"}, .F. )
    _HB_MEMBER { lCalcular } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lCalcular"}, .F. )
    _HB_MEMBER { cPrtStr } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cPrtStr"}, .F. )
    _HB_MEMBER { lReceberPorPeriodo } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lReceberPorPeriodo"}, .F. )
    _HB_MEMBER { nT } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nT"}, .F. )
    _HB_MEMBER { lOrdemAscendente } ; oClass:AddMultiData(, .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lOrdemAscendente"}, .F. )
    _HB_MEMBER { lReload } ; oClass:AddMultiData(, .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lReload"}, .F. )
    _HB_MEMBER { nGulosa } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nGulosa"}, .F. )
    _HB_MEMBER { nTab } ; oClass:AddMultiData(, 16, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTab"}, .F. )


    _HB_MEMBER { nTop } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTop"}, .F. )
    _HB_MEMBER { nLeft } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLeft"}, .F. )
    _HB_MEMBER { nRight } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRight"}, .F. )
    _HB_MEMBER { nNumRows } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nNumRows"}, .F. )
    _HB_MEMBER { nNumCols } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nNumCols"}, .F. )

    _HB_MEMBER { nPos } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPos"}, .F. )
    _HB_MEMBER { nAtTop } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nAtTop"}, .F. )
    _HB_MEMBER { nArrLen } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nArrLen"}, .F. )
    _HB_MEMBER { nRowsClr } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRowsClr"}, .F. )


    _HB_MEMBER { cLine } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cLine"}, .F. )
    _HB_MEMBER { nRow } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRow"}, .F. )
    _HB_MEMBER { nCol } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nCol"}, .F. )
    _HB_MEMBER { lSelect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lSelect"}, .F. )
    _HB_MEMBER { alSelect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"alSelect"}, .F. )
    _HB_MEMBER { lHiLite } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lHiLite"}, .F. )


    _HB_MEMBER New() AS CLASS TReceposi; oClass:AddMethod( "New", @TReceposi_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Destroy(); oClass:SetDestructor( @TReceposi_Destroy() )
    _HB_MEMBER Resetar(); oClass:AddMethod( "Resetar", @TReceposi_Resetar(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER RenewVar(); oClass:AddMethod( "RenewVar", @TReceposi_RenewVar(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Achoice_(); oClass:AddMethod( "Achoice_", @TReceposi_Achoice_(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Achoice(); oClass:AddMethod( "Achoice", @TReceposi_Achoice(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER MaBox_(); oClass:AddMethod( "MaBox_", @TReceposi_MaBox_(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER PrintPosi(); oClass:AddMethod( "PrintPosi", @TReceposi_PrintPosi(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Redraw_(); oClass:AddMethod( "Redraw_", @TReceposi_Redraw_(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Hello(); oClass:AddMethod( "Hello", @TReceposi_Hello(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ResetSelecao(); oClass:AddMethod( "ResetSelecao", @TReceposi_ResetSelecao(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ResetAll(); oClass:AddMethod( "ResetAll", @TReceposi_ResetAll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER RedrawSelecao(); oClass:AddMethod( "RedrawSelecao", @TReceposi_RedrawSelecao(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER RedrawVencer(); oClass:AddMethod( "RedrawVencer", @TReceposi_RedrawVencer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER RedrawVencido(); oClass:AddMethod( "RedrawVencido", @TReceposi_RedrawVencido(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER RedrawRecibo(); oClass:AddMethod( "RedrawRecibo", @TReceposi_RedrawRecibo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER RedrawGeral(); oClass:AddMethod( "RedrawGeral", @TReceposi_RedrawGeral(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ZerarSelecao(); oClass:AddMethod( "ZerarSelecao", @TReceposi_ZerarSelecao(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ZerarRecibo(); oClass:AddMethod( "ZerarRecibo", @TReceposi_ZerarRecibo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ZerarVencer(); oClass:AddMethod( "ZerarVencer", @TReceposi_ZerarVencer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ZerarVencido(); oClass:AddMethod( "ZerarVencido", @TReceposi_ZerarVencido(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ZerarGeral(); oClass:AddMethod( "ZerarGeral", @TReceposi_ZerarGeral(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ZerarRescisao(); oClass:AddMethod( "ZerarRescisao", @TReceposi_ZerarRescisao(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER BarraSoma(); oClass:AddMethod( "BarraSoma", @TReceposi_BarraSoma(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ImprimeSoma(); oClass:AddMethod( "ImprimeSoma", @TReceposi_ImprimeSoma(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER _SomaPago( nValorTotal, nValorPago); oClass:AddMethod( "_SomaPago", @TReceposi__SomaPago(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER AssignColor(); oClass:AddMethod( "AssignColor", @TReceposi_AssignColor(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER LeftEqI( string, cKey); oClass:AddMethod( "LeftEqI", @TReceposi_LeftEqI(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Ach_Select( alSelect, nPos); oClass:AddMethod( "Ach_Select", @TReceposi_Ach_Select(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Ach_Limits( nFrstItem, nLastItem, nItems, alSelect, acItems); oClass:AddMethod( "Ach_Limits", @TReceposi_Ach_Limits(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Displine( cLine, nRow, nCol, lSelect, lHiLite, nNumCols, nCurElemento); oClass:AddMethod( "Displine", @TReceposi_Displine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DispPage( acItems, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nArrLen, nRowsClr); oClass:AddMethod( "DispPage", @TReceposi_DispPage(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER HitTest( nTop, nLeft, nBottom, nRight, mRow, mCol); oClass:AddMethod( "HitTest", @TReceposi_HitTest(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER AddColor( nColor); oClass:AddMethod( "AddColor", @TReceposi_AddColor(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER CloneVarColor(); oClass:AddMethod( "CloneVarColor", @TReceposi_CloneVarColor(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ColorToAmbiente(); oClass:AddMethod( "ColorToAmbiente", @TReceposi_ColorToAmbiente(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER AmbienteToColor(); oClass:AddMethod( "AmbienteToColor", @TReceposi_AmbienteToColor(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Reset(); oClass:AddMethod( "Reset", @TReceposi_Reset(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ResetCorSelecao(); oClass:AddMethod( "ResetCorSelecao", @TReceposi_ResetCorSelecao(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DeleteReg( nReg); oClass:AddMethod( "DeleteReg", @TReceposi_DeleteReg(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER RegistroEmBranco( cCodi,cFatu); oClass:AddMethod( "RegistroEmBranco", @TReceposi_RegistroEmBranco(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER AjustaCorInicio( nAtraso, nT); oClass:AddMethod( "AjustaCorInicio", @TReceposi_AjustaCorInicio(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER AjustaCorFinal( nAtraso, nT); oClass:AddMethod( "AjustaCorFinal", @TReceposi_AjustaCorFinal(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER cStrComValor( nSomaParcial); oClass:AddMethod( "cStrComValor", @TReceposi_cStrComValor(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER cStrSemValor(); oClass:AddMethod( "cStrSemValor", @TReceposi_cStrSemValor(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER cStrAll(); oClass:AddMethod( "cStrAll", @TReceposi_cStrAll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER AjustaGeral(); oClass:AddMethod( "AjustaGeral", @TReceposi_AjustaGeral(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER sTrFormataATodos( nT); oClass:AddMethod( "sTrFormataATodos", @TReceposi_sTrFormataATodos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Destroy(); oClass:AddMethod( "Destroy", @TReceposi_Destroy(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Show(); oClass:AddMethod( "Show", @TReceposi_Mabox_(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Redraw(); oClass:AddMethod( "Redraw", @TReceposi_Redraw_(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TReceposi ;

static FUNCTION TReceposi_Destroy( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    self := nil
    return nil

static FUNCTION TReceposi_New( nBoxRow, nBoxCol, nBoxRow1, nBoxCol1, cTop, cBottom ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    self:cWho  := "TTReceposi"
    self:cNome := ProcName()

    hb_default(@nBoxRow,  8)
    hb_default(@nBoxCol,  0)
    hb_default(@nBoxRow1, ms_maxrow()-1)
    hb_default(@nBoxCol1, maxcol())
    hb_default(@cTop,     ::cWho)
    hb_default(@cBottom,  ::cNome)

    ::nBoxRow   := nBoxRow
    ::nBoxCol   := nBoxCol
    ::nBoxRow1  := nBoxRow1
    ::nBoxCol1  := nBoxCol1
    ::cTop      := cTop
    ::cBottom   := cBottom
    ::AssignColor()
    return self

static FUNCTION TReceposi_Mabox_( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    MaBox(::nBoxRow, ::nBoxCol, ::nBoxRow1, ::nBoxCol1, ::cTop, ::cBottom)
    return self

static FUNCTION TReceposi_Redraw_( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::MaBox_()
    if !empty(::aBottom)
        ::PrintPosi(::nPrtRow, ::nPrtCol, ::aBottom)
    endif
    return self

static FUNCTION TReceposi_PrintPosi( nRow, nCol ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::nPrtRow := nRow
    ::nPrtCol := nCol
    ::aBottom := { ::cStrRecibo, ::cStrVencido, ::cStrVencer, ::cStrGeral }
    Print(::nPrtRow-3, ::nPrtCol, ::aBottom[1], ::CorRecibo,  MaxCol()+1)
    Print(::nPrtRow-2, ::nPrtCol, ::aBottom[2], ::CorVencido, MaxCol()+1)
    Print(::nPrtRow-1, ::nPrtCol, ::aBottom[3], ::CorVencer,  MaxCol()+1)
    Print(::nPrtRow,   ::nPrtCol, ::aBottom[4], ::CorVencido, MaxCol()+1)
    return self

static FUNCTION TReceposi_RegistroEmBranco( cCodi,cFatu ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi



























    Aadd( ::xTodos, {    Repl("0",6)+"-00",    cTod("01/01/1900"),    cTod("01/01/1900"),    0,    0,    0,    0,    0,    0,    "00000",    Space(40),    dTos(cTod("")) + dTos(cTod(""))+Space(9),    dTos(cTod("")) + Space(9),    dTos(cTod("")) + dTos(cTod("")),    iif(::nChoice == 5, cFatu, Space(9)),    cTod(""), .T., 0,    dTos(cTod("")) + Space(9) + dTos(cTod("")),    dTos(cTod("")) + Space(9) + Space(9) + dTos(cTod("")),    dTos(cTod("")) + Space(9) + dTos(cTod("")),    dTos(cTod("")) + cCodi + Space(9) + dTos(cTod("")),    0,    0,    })
    return .T.


static FUNCTION TReceposi_RenewVar( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::aTodos          := {}
    ::xTodos          := {}
    ::aCodi        := {}
   ::aRecno      := {}
    ::aRescisao   := {}
   ::aAtivo      := {}
    ::aAtivoSwap  := {}
    ::aHistRecibo := {}
    ::aUserRecibo := {}
    ::aReciboImpresso := {}
    ::aDataPag        := {}
    ::alMulta     := {}
    ::CurElemento := 1
    ::nQtdDoc       := 0
    ::Color_pFore := {}
    ::Color_pBack := {}
    ::Color_pUns  := {}
    ::nPrtRow      := MaxRow()
    return self

static FUNCTION TReceposi_DeleteReg( nReg ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
   hb_default(@nReg, ::CurElemento)
    HB_ADel( ::aTodos,          nReg, .T. )
    HB_ADel( ::xTodos,          nReg, .T. )
    HB_ADel( ::aCodi,           nReg, .T. )
    HB_ADel( ::aRecno,          nReg, .T. )
    HB_ADel( ::aRescisao,       nReg, .T. )
   HB_ADel( ::aAtivo,          nReg, .T. )
    HB_ADel( ::aAtivoSwap,      nReg, .T. )
    HB_ADel( ::aHistRecibo,     nReg, .T. )
    HB_ADel( ::aUserRecibo,     nReg, .T. )
    HB_ADel( ::aDataPag,        nReg, .T. )
    HB_ADel( ::aReciboImpresso, nReg, .T. )
    HB_ADel( ::alMulta,         nReg, .T. )
    HB_ADel( ::CurElemento,     nReg, .T. )
    HB_ADel( ::nQtdDoc,            nReg, .T. )
    HB_ADel( ::Color_pFore,     nReg, .T. )
    HB_ADel( ::Color_pBack,     nReg, .T. )
    HB_ADel( ::Color_pUns,      nReg, .T. )
    ::aBottom := ::BarraSoma()
return self

static FUNCTION TReceposi_Resetar( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    self:New()
return self

static FUNCTION TReceposi_CloneVarColor( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    LOCAL xLen  := Len(::xTodos)
    LOCAL pLen  := Len(::Color_pFore)
    LOCAL oLen  := Len(oAmbiente:Color_pFore)
    LOCAL nT    := 0

    if oLen == 0
        ::ColorToAmbiente()
    else
        ::AmbienteToColor()
    endif
    pLen := Len(::Color_pFore)
    oLen := Len(oAmbiente:Color_pFore)

    if pLen < xLen
        for nT := pLen To xLen
            ::AddColor()
        next
    endif
    ::ColorToAmbiente()
    return self

static FUNCTION TReceposi_Reset( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    ::RenewVar()
    ::ColorToAmbiente()
return self

static FUNCTION TReceposi_ColorToAmbiente( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    oAmbiente:aAtivo      := ::aAtivo
    oAmbiente:aAtivoSwap  := ::aAtivoSwap
    oAmbiente:Color_pFore := ::Color_pFore
    oAmbiente:Color_pBack := ::Color_pBack
    oAmbiente:Color_pUns  := ::Color_pUns
return self

static FUNCTION TReceposi_AmbienteToColor( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    ::aAtivo      := oAmbiente:aAtivo
    ::aAtivoSwap  := oAmbiente:aAtivoSwap
    ::Color_pFore := oAmbiente:Color_pFore
    ::Color_pBack := oAmbiente:Color_pBack
    ::Color_pUns  := oAmbiente:Color_pUns
    return self

static FUNCTION TReceposi_AddColor( nColor ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

__DefaultNIL(@nColor, ::CorVencido)

aadd( ::Color_pFore,  nColor )
aadd( ::Color_pBack,  oAmbiente:CorLightBar )
aadd( ::Color_pUns,   ::CorRecibo )
aadd( ::aAtivo,       .T.)
aadd( ::aAtivoSwap,   .T.)
return self

static FUNCTION TReceposi_AssignColor( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    ::Color_pFore   := {}
    ::Color_pBack   := {}
    ::Color_pUns    := {}
    ::CorRecibo     := AscanCor(13)
    ::CorVencido    := AscanCor(16)
    ::CorVencer     := AscanCor(11)
    ::CorSelecao    := AscanCor(10)
    ::CorAviso      := AscanCor(15)
    ::CorDuplicado  := AscanCor(04)
    ::CorAlterado   := AscanCor(14)
    ::CorDesativado := AscanCor(12)
    Afill((::Color_pFore := Array(Len(::xTodos))), ::CorVencido )
    Afill((::Color_pBack := Array(Len(::xTodos))), oAmbiente:CorLightBar )
    Afill((::Color_pUns  := Array(Len(::xTodos))), ::CorRecibo )
    ::ColorToAmbiente()
return self

static FUNCTION TReceposi_Achoice_( aTodos, aAtivo, cFuncao, lPageCircular ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
   ::Achoice(::nBoxRow+1, ::nBoxCol+1, ::nBoxRow1-1, ::nBoxCol1-1, ::aTodos, ::aAtivo, cFuncao, NIL, NIL, lPageCircular, ::Color_pFore, ::Color_pBack, ::Color_pUns)
    return self

static FUNCTION TReceposi_Hello ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    QOut( "Hello", self:cWho )
    QOut( "Hello", ::cNome )
    return self

static FUNCTION TReceposi_ResetCorSelecao ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    LOCAL xLen := Len(::aCurElemento_Selecao)
    LOCAL nT
    for nT := 1 to xLen
        ::aAtivo[::aCurElemento_Selecao[nT]]         := .T.
        oAmbiente:aAtivo[::aCurElemento_Selecao[nT]] := .T.
    next
    return self

static FUNCTION TReceposi_ResetSelecao ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::ZerarSelecao()
    ::RedrawSelecao()
    ::Redraw_()
    return self

static FUNCTION TReceposi_ResetAll ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::ZerarSelecao()
    ::RedrawRecibo()
    ::RedrawVencido()
    ::RedrawVencer()
    ::RedrawGeral()
    ::Redraw_()
    return self

static FUNCTION TReceposi_ZerarSelecao ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::aDocnr_Selecao_Imprimir := {}
    ::aSoma_Selecao_Imprimir  := {}
    ::aObs_Selecao_Imprimir   := {}
    ::aCurElemento_Selecao    := {}

    ::nSoma_Total_Imprimir    := 0
    ::nPrincipalSelecao       := 0
    ::nRescisaoSelecao        := 0

    ::nJurosSelecao           := 0
    ::nMultaSelecao           := 0
    return self

static FUNCTION TReceposi_ZerarRecibo ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::nTotal_Recibo           := 0
    ::nPrincipal_Recibo       := 0
    ::nJuros_Recibo           := 0
    ::nMulta_Recibo           := 0
    ::nQtdDoc_Recibo          := 0
    return self

static FUNCTION TReceposi_ZerarVencer ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::nTotal_Vencer           := 0
    ::nPrincipal_Vencer       := 0
    ::nJuros_Vencer           := 0
    ::nMulta_Vencer           := 0
    ::nQtdDoc_Vencer          := 0
    return self

static FUNCTION TReceposi_ZerarVencido ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::nTotal_Vencido          := 0
    ::nPrincipal_Vencido      := 0
    ::nJuros_Vencido          := 0
    ::nMulta_Vencido          := 0
    ::nQtdDoc_Vencido         := 0
    return self

static FUNCTION TReceposi_ZerarGeral ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::nTotal_Geral            := 0
    ::nPrincipal_Geral        := 0
    ::nJuros_Geral            := 0
    ::nMulta_Geral            := 0
    ::nQtdDoc_Geral           := 0
    return self

static FUNCTION TReceposi_ZerarRescisao ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::nPrincipal_Rescisao     := 0
    ::nJuros_Rescisao         := 0
    ::nMulta_Rescisao         := 0
    ::nTotal_Rescisao         := 0
    ::nQtdDoc_Rescisao        := 0
    return self

static FUNCTION TReceposi_RedrawRecibo ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::cStrRecibo := " RECIBO EMITIDO ¯¯ {"
    ::cStrRecibo += StrZero(::nQtdDoc_Recibo,5)
    ::cStrRecibo += "}" + Space(::nTab)
    ::cStrRecibo += Tran(::nPrincipal_Recibo, "@E 999,999.99") + Space(9)
    ::cStrRecibo += Tran(::nJuros_Recibo,     "@E 99,999.99")  + Space(1)
    ::cStrRecibo += Tran(::nMulta_Recibo,     "@E 99,999.99")  + Space(1)
    ::cStrRecibo += Tran(::nTotal_Recibo,     "@E 999,999.99") + Space(1)
    ::cStrRecibo += Tran(::nMulta_Recibo,     "@E 999,999.99")
    return(::cStrRecibo)

static FUNCTION TReceposi_RedrawVencido ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
   ::cStrVencido := " ABERTO VENCIDO ¯¯ {"
    if ::nOrdem == 3
    ::cStrVencido := "   PAGO VENCIDO ¯¯ {"
    endif
    ::cStrVencido += StrZero(::nQtdDoc_Vencido,5)
    ::cStrVencido += "}" + Space(::nTab)
    ::cStrVencido += Tran(::nPrincipal_Vencido, "@E 999,999.99") + Space(9)
    ::cStrVencido += Tran(::nJuros_Vencido,     "@E 99,999.99")  + Space(1)
    ::cStrVencido += Tran(::nMulta_Vencido,     "@E 99,999.99")  + Space(1)
    ::cStrVencido += Tran(::nTotal_Vencido,     "@E 999,999.99") + Space(1)
    ::cStrVencido += Tran(::nTotal_Vencido,     "@E 999,999.99")
    return(::cStrVencido)

static FUNCTION TReceposi_RedrawVencer ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::cStrVencer := " ABERTO VENCER  ¯¯ {"
    if ::nOrdem == 3
    ::cStrVencer := "   PAGO VENCER  ¯¯ {"

    endif
    ::cStrVencer += StrZero(::nQtdDoc_Vencer,5)
    ::cStrVencer += "}" + Space(::nTab)
    ::cStrVencer += Tran(::nPrincipal_Vencer, "@E 999,999.99") + Space(9)
    ::cStrVencer += Tran(::nJuros_Vencer,     "@E 99,999.99")  + Space(1)
    ::cStrVencer += Tran(::nMulta_Vencer,     "@E 99,999.99")  + Space(1)
    ::cStrVencer += Tran(::nTotal_Vencer,     "@E 999,999.99") + space(1)
    ::cStrVencer += Tran(::nTotal_Rescisao,   "@E 999,999.99") + space(1)
    ::cStrVencer += Tran(::nTotal_Vencido + ::nTotal_Rescisao,   "@E 999,999.99")
    return(::cStrVencer)

static FUNCTION TReceposi_RedrawGeral ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::cStrGeral := " TOTAL GERAL    ¯¯ {"
    ::cStrGeral += StrZero(::nQtdDoc_Geral, 5)
    ::cStrGeral += "}" + Space(::nTab)
    ::cStrGeral += Tran(::nPrincipal_Geral, "@E 999,999.99") + Space(9)
    ::cStrGeral += Tran(::nJuros_Geral,     "@E 99,999.99")  + Space(1)
    ::cStrGeral += Tran(::nMulta_Geral,     "@E 99,999.99")  + Space(1)
    ::cStrGeral += Tran(::nTotal_Geral,     "@E 999,999.99") + Space(1)
    ::cStrGeral += Tran(::nTotal_Vencido + ::nTotal_Rescisao,   "@E 999,999.99")
    return(::cStrGeral)

static FUNCTION TReceposi_RedrawSelecao ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi
    ::cStrSelecao := " TOTAL SELECAO  ¯¯ {"
    ::cStrSelecao += StrZero(Len(::aDocnr_Selecao_Imprimir),5)
    ::cStrSelecao += "}" + Space(::nTab)
    ::cStrSelecao += Tran(::nPrincipalSelecao,         "@E 999,999.99") + Space(9)
    ::cStrSelecao += Tran(::nJurosSelecao,                   "@E 99,999.99")  + Space(1)
    ::cStrSelecao += Tran(::nMultaSelecao,                 "@E 99,999.99")  + Space(1)
    ::cStrSelecao += Tran(::nSoma_Total_Imprimir,   "@E 999,999.99") + Space(1)
    ::cStrSelecao += Tran(::nRescisaoSelecao,       "@E 999,999.99") + space(1)
    oMenu:StatInf("")
    oMenu:ContaReg( ::cStrSelecao, 31)
    return self

static FUNCTION TReceposi__SomaPago( nValorTotal, nValorPago ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

     ::cStrRecibo := " TOTAL GERAL ¯¯ "
     ::cStrRecibo += Space(27 + ::nTab)
     ::cStrRecibo += Tran(nValorTotal, "@E 999,999,999.99")
     ::cStrRecibo += Space(01)
     ::cStrRecibo += Tran(nValorPago,  "@E 999,999,999.99")
     return( ::cStrRecibo)


static FUNCTION TReceposi_ImprimeSoma( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    ::aBottom := ::BarraSoma()
    return self


static FUNCTION TReceposi_BarraSoma( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    LOCAL xLen            := Len(::xTodos)
    LOCAL nLastColor   := ::nCorZebradoBranco
    LOCAL nSomaParcial := 0
    LOCAL nAtraso
    LOCAL nDiaComUso
    LOCAL nDiaSemUso
    LOCAL nVlrComUso
    LOCAL nVlrSemUso
    LOCAL cStr
    LOCAL nLen
    LOCAL nVlr
    LOCAL cObs
    LOCAL oBloco

    ::ZerarRecibo()
    ::ZerarVencer()
    ::ZerarVencido()
    ::ZerarRescisao()
    ::ZerarGeral()

    ::aRescisao  := Array(xLen)
    ::nT         := 0
    ::nGulosa    := 90

    if oAmbiente:lReceber .AND. ::Posireceber
        For ::nT := 1 To xLen
            if ::xTodos[::nT, 1] == "000000-00"
               loop
            endif


            if (::aReciboImpresso[::nT])
                ::aTodos[::nT]            := Left(::aTodos[::nT], ::nGulosa) + " {" + if( MaxCol() > 79, ltrim(rtrim(::xTodos[::nT,11])) + "}", "{}")
                ::nPrincipal_Recibo       += ::xTodos[::nT, 5]
                ::nMulta_Recibo           += ::xTodos[::nT, 7]
                ::nJuros_Recibo               += ::xTodos[::nT, 8]
                ::nTotal_Recibo           += ::xTodos[::nT, 9]
                ::nQtdDoc_Recibo++

                if !(oAmbiente:lK_Ctrl_Ins)
                    ::Color_pFore[::nT]    := ::CorRecibo
                    if (::xTodos[::nT, 5] - ::xTodos[::nT, 9]) > 0
                        ::Color_pFore[::nT]    := ::CorVencido
                    endif
                endif

                if ::nOrdem == 1
                    ::Color_pFore[::nT]    := ::CorRecibo
                    if ::nChoice = 3
                        ::aAtivo[::nT]         := .T.
                    endif
                endif

                if ::nOrdem == 3
                    ::Color_pFore[::nT]    := ::CorRecibo
                endif

            else
                ::aTodos[::nT]            := ::sTrFormataATodos(::nT)
            endif

            nAtraso := Atraso( Date(), ::xTodos[::nT,3])
            ::AjustaCorInicio(nAtraso, ::nT)



            if ::nOrdem == 3
                if (::aReciboImpresso[::nT])
                    if ::xTodos[::nT,3] <= ::xTodos[::nT,16]
                        ::nPrincipal_Vencido += ::xTodos[::nT,5]
                        ::nMulta_Vencido     += ::xTodos[::nT,7]
                        ::nJuros_Vencido     += ::xTodos[::nT,8]
                        ::nTotal_Vencido     += ::xTodos[::nT,9]
                        ::nQtdDoc_Vencido++
                    endif
                endif
            else
                if ::xTodos[::nT,3] <= Date()
                    if !(::aReciboImpresso[::nT])
                        ::nPrincipal_Vencido += ::xTodos[::nT,5]
                        ::nMulta_Vencido     += ::xTodos[::nT,7]
                        ::nJuros_Vencido     += ::xTodos[::nT,8]
                        ::nTotal_Vencido     += ::xTodos[::nT,9]
                        ::nQtdDoc_Vencido++
                    endif
                endif
            endif



            if ::nOrdem == 3
                if (::aReciboImpresso[::nT])
                    if ::xTodos[::nT,3] > ::xTodos[::nT,16]
                        ::nPrincipal_Vencer   += ::xTodos[::nT,5]
                        ::nMulta_Vencer        += ::xTodos[::nT,7]
                        ::nJuros_Vencer        += ::xTodos[::nT,8]
                        ::nTotal_Vencer        += ::xTodos[::nT,9]
                        ::nQtdDoc_Vencer++
                    endif
                endif
            else
                if ::xTodos[::nT,3] > Date()
                    if !(::aReciboImpresso[::nT])
                        ::nPrincipal_Vencer   += ::xTodos[::nT,5]
                        ::nMulta_Vencer        += ::xTodos[::nT,7]
                        ::nJuros_Vencer        += ::xTodos[::nT,8]
                        ::nTotal_Vencer        += ::xTodos[::nT,9]
                        ::nQtdDoc_Vencer++
                    endif
                endif
            endif


            nVlr := ::xTodos[::nT,5]
            cStr := ::aTodos[::nT]
            nLen := Len(cStr)
            cObs := Right(cStr, nLen-::nGulosa)

            if ::nOrdem <> 3
               if !(::aReciboImpresso[::nT])
                    if nAtraso < 0
                        if nAtraso < -30
                            nVlr *= 0.5
                            cstr := ::aTodos[::nT] := Left( ::aTodos[::nT], ::nGulosa) + " " + Tran(nVlr,  "@E 999,999.99") + " {50%}"
                            cstr += Space(01)
                            cstr += cObs
                        else
                            nDiaComUso := (30 + nAtraso)
                            nDiaSemUso := (30 - nDiaComUso)
                            nVlrComUso := (nDiaComUso * (nVlr/30))
                            nVlrSemUso := (nDiaSemUso * (nVlr/30)*0.5)
                            nVlr          := (nVlrComUso + nVlrSemUso)


                            cstr       := ::aTodos[::nT] := Left( ::aTodos[::nT], ::nGulosa) + " " + Tran(nVlr, "@E 999,999.99") +  " {" + StrZero(nDiaComUso,2) + "D}=" + ltrim(rtrim(Tran(nVlrComUso, "@E 999,999.99"))) +  " + {" + StrZero(nDiaSemUso,2) + "D}=" + ltrim(rtrim(Tran(nVlrSemUso, "@E 999,999.99"))) + " {50%}"
                            cstr       += Space(01)
                            cstr       += cObs
                        endif
                    endif
                endif
            endif

            if ::xTodos[::nT,3] > Date()
                if !(::aReciboImpresso[::nT])
                    ::nPrincipal_Rescisao += nVlr
                    ::nMulta_Rescisao        += ::xTodos[::nT,7] /2
                    ::nJuros_Rescisao        += ::xTodos[::nT,8] /2
                    ::nTotal_Rescisao        += nVlr
                    ::aTodos[::nT]        := cStr
                    ::nQtdDoc_Rescisao++
                endif
            endif
            ::aRescisao[::nT] := nVlr


            if oAmbiente:lMostrarSoma
                if (::aReciboImpresso[::nT])
                    nSomaParcial += ::xTodos[::nT,7]
                    oBloco       := if(oAmbiente:ZebrarAmostragem, {||Right(::xTodos[::nT+1,1], 8) <> Right(::xTodos[::nT,1], 8)} , {||::xTodos[::nT+1,16] <> ::xTodos[::nT,16]})
                    if ::nT < xLen
                        if Eval(oBloco)
                           cStr         := ::cStrComValor(nSomaParcial)
                            nSomaParcial := 0
                        else
                            if !(::aReciboImpresso[::nT + 1])
                                cStr         := ::cStrComValor(nSomaParcial)
                                nSomaParcial := 0
                            else
                                cStr := ::cStrSemValor(::nT)
                            endif
                        endif
                    else
                        cStr := ::cStrComValor(nSomaParcial)
                    endif
                else
                    if !(::xTodos[::nT,3] > Date())
                        if nSomaParcial <> 0
                            cStr         := ::cStrComValor(nSomaParcial)
                            nSomaParcial := 0
                        else
                            cStr := ::cStrSemValor()
                        endif
                    endif
                endif
                ::aTodos[::nT] := cStr
            endif


            if oAmbiente:ZebrarAmostragem
                if ::nT > 1
                  if Right(::xTodos[::nT-1 , 1], 8) <> Right(::xTodos[::nT,1], 8)
                        nLastColor := if(nLastColor == ::nCorZebradoBranco, ::nCorZebradoVerde, ::nCorZebradoBranco)
                    endif
                endif
                ::Color_pFore[::nT] := nLastColor
            endif
            ::AjustaCorFinal(nAtraso, ::nT)

        Next
    endif
    ::AjustaGeral()
    ::cStrAll()
    ::Redraw_()
    return self


static FUNCTION TReceposi_cStrAll( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    ::cStrRecibo    := ::RedrawRecibo
    ::cStrVencido   := ::RedrawVencido
    ::cstrVencer    := ::RedrawVencer
    ::cstrGeral     := ::RedrawGeral
    return self


static FUNCTION TReceposi_AjustaGeral( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    if ::nOrdem <> 3
        ::nPrincipal_Geral := ::nPrincipal_Recibo + ::nPrincipal_Vencido + ::nPrincipal_Vencer
        ::nMulta_Geral     := ::nMulta_Recibo     + ::nMulta_Vencido     + ::nMulta_Vencer
        ::nJuros_Geral      := ::nJuros_Recibo     + ::nJuros_Vencido     + ::nJuros_Vencer
        ::nTotal_Geral     := ::nTotal_Recibo     + ::nTotal_Vencido     + ::nTotal_Vencer
        ::nQtdDoc_Geral    := ::nQtdDoc_Recibo    + ::nQtdDoc_Vencido    + ::nQtdDoc_Vencer
    else
        ::nPrincipal_Geral := ::nPrincipal_Recibo
        ::nMulta_Geral     := ::nMulta_Recibo
        ::nJuros_Geral      := ::nJuros_Recibo
        ::nTotal_Geral     := ::nTotal_Recibo
        ::nQtdDoc_Geral    := ::nQtdDoc_Recibo
    endif
    return self


static function TReceposi_cStrComValor( nSomaParcial ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    LOCAL cStr
    cStr := Left( ::aTodos[::nT], ::nGulosa) + " " + Tran(nSomaParcial, "@E 999,999.99")  + SubStr( ::aTodos[::nT], ::nGulosa + 1 , 200)
    return(cStr)


static function TReceposi_cStrSemValor( ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    LOCAL cStr
    cStr := Left( ::aTodos[::nT], ::nGulosa) + Space(11) + SubStr( ::aTodos[::nT], ::nGulosa + 1 , 200)
    return( cStr)


static FUNCTION TReceposi_AjustaCorInicio( nAtraso, nT ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    if nAtraso < 0
        if ::Color_pFore[nT] == ::CorVencido
            ::Color_pFore[nT] := ::CorVencer
        endif
    endif
    if nAtraso > oAmbiente:aSciArray[1,6]
        if ::Color_pFore[nT] == ::CorVencido
            ::Color_pFore[nT] := ::CorVencido
        endif
    endif
    if nAtraso >= 0 .AND. nAtraso <= oAmbiente:aSciArray[1,6]
        if ::Color_pFore[nT] == ::CorVencido
            ::Color_pFore[nT] := ::CorAviso
        endif
    endif
    return self


static FUNCTION TReceposi_AjustaCorFinal( nAtraso, nT ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    if !(::aReciboImpresso[nT])
        if nAtraso < 0

                ::Color_pFore[nT] := ::CorVencer

        endif
        if nAtraso > oAmbiente:aSciArray[1,6]

                ::Color_pFore[nT] := ::CorVencido

        endif
        if nAtraso >= 0 .AND. nAtraso <= oAmbiente:aSciArray[1,6]

                ::Color_pFore[nT] := ::CorAviso

        endif
    endif
    return self


static function TReceposi_sTrFormataATodos( nT ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    LOCAL cCodi  := ::xTodos[nT,10]










    LOCAL cTodos := ::xTodos[nT,1]                     + " " +  Left( Dtoc( ::xTodos[nT,2]),5 ) + " " +  Dtoc(::xTodos[nT,3])            + " " +  StrZero( ::xTodos[nT,4], 4) + " {" +  Tran(::xTodos[nT,24], "@E 99,999.99")  + "} " +  Tran(::xTodos[nT,5],        "@E 99,999.99")  + " " +  Tran(::xTodos[nT,6],   "@E 9,999.99")   + " " +  Tran(::xTodos[nT,8],      "@E 9,999.99")   + " " +  Tran(::xTodos[nT,7],      "@E 99,999.99")  + " " +  Tran(::xTodos[nT,9],       "@E 999,999.99") + " {" +  if( MaxCol() > 79, ltrim(rtrim(::xTodos[nT,11])) + "}", "{}")
    ::aCodi[nT]  := cCodi
    ::aTodos[nT] := cTodos
    return(cTodos)




Function TReceposiNew(nBoxRow, nBoxCol, nBoxRow1, nBoxCol1, cTop, cBottom)
    return(TReceposi():New(nBoxRow, nBoxCol, nBoxRow1, nBoxCol1, cTop, cBottom))






















static FUNCTION TReceposi_Achoice( nTop, nLeft, nBottom, nRight, acItems, xSelect, xUserFunc, nPos, nHiLiteRow, lPageCircular ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

   LOCAL nNumCols
   LOCAL nNumRows
   LOCAL nRowsClr
   LOCAL alSelect
   LOCAL nNewPos   := 0
   LOCAL lFinished
   LOCAL nKey      := 0
   LOCAL nMode
   LOCAL nAtTop
   LOCAL nItems    := 0
   LOCAL nGap


   LOCAL lUserFunc
   LOCAL nUserFunc
   LOCAL nSaveCsr
   LOCAL nFrstItem := 0
   LOCAL nLastItem := 0

   LOCAL bAction
   LOCAL cKey
   LOCAL nAux
    if lPageCircular == NIL ; lPageCircular := .T. ; END

    hb_default( @nTop, 0)
   hb_default( @nBottom, 0)

   hb_default( @nLeft, 0 )
   hb_default( @nRight, 0 )

   if nRight > MaxCol()
      nRight := MaxCol()
   endif

   if nBottom > MaxRow()
      nBottom := MaxRow()-2
   endif

   if ! HB_ISARRAY( ::aTodos ) .OR. Len( ::aTodos ) == 0
      SetPos( nTop, nRight + 1 )
      return 0
   endif

   nSaveCsr := SetCursor( 0 )
   ColorSelect( 0 )






   if Empty( xUserFunc ) .AND. ValType( ::aAtivo ) $ "CBS"
      xUserFunc := ::aAtivo
      ::aAtivo   := NIL
   endif

   lUserFunc := ! Empty( xUserFunc ) .AND. ValType( xUserFunc ) $ "CBS"

   if ! HB_ISARRAY( ::aAtivo ) .AND. ! HB_ISLOGICAL( ::aAtivo )
      ::aAtivo := .T.
   endif

   hb_default( @nPos, 1 )
   hb_default( @nHiLiteRow, 0 )

   nNumCols := nRight - nLeft + 1
   nNumRows := nBottom - nTop + 1

   if HB_ISARRAY( ::aAtivo )
      alSelect := ::aAtivo
   else
      alSelect := Array( Len( ::aTodos ) )
      AFill( alSelect, ::aAtivo )
   endif

   if ( nMode := ::Ach_Limits( @nFrstItem, @nLastItem, @nItems, alSelect, ::aTodos ) ) == 4
      nPos := 0
        ::CurElemento := nPos
   endif


   nPos := Min( Max( nFrstItem, nPos ), nLastItem )
    ::CurElemento := nPos


   nHiLiteRow := Min( Max( 0, nHiLiteRow ), nNumRows - 1 )


   nAtTop := Min( Max( 1, Max( 1, nPos - nHiLiteRow ) ), nItems )


   if ( nAtTop + nNumRows - 1 ) > nItems
      nAtTop := Max( 1, nItems - nNumrows + 1 )
   endif

   ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems, nItems )

   lFinished := ( nMode == 4 )
   if lFinished .AND. lUserFunc
       Do( xUserFunc, nMode, nPos, nPos - nAtTop )
   endif

   WHILE !lFinished

        ::nTop     := nTop
        ::nLeft    := nLeft
        ::nRight   := nRight
        ::nNumRows := nNumRows
        ::nNumCols := nNumCols
        ::nPos     := nPos
        ::nAtTop   := nAtTop
        alSelect   := ::aAtivo
        ::alSelect := alSelect
        acItems    := ::aTodos
        xSelect    := ::aAtivo

        if nMode <> 3 .AND. nMode <> 4 .AND. nMode <> 10
         nKey  := Inkey( 0 )
         nMode := 0
      endif

      DO CASE
        case nMode = 10
           nNewPos := ::CurElemento
            while !::Ach_Select( alSelect, nNewPos )
            nNewPos--
         ENDDO
         if ( nNewPos >= nAtTop .AND. nNewPos <= nAtTop + nNumRows - 1 )
            ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
            nPos := nNewPos
            ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .T., nNumCols, nPos )
         else
            DispBegin()
            ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
            hb_Scroll( nTop, nLeft, nBottom, nRight, nNewPos - ( nAtTop + nNumRows - 1 ) )
            nAtTop := nNewPos
            nPos   := Max( nPos, nAtTop + nNumRows - 1 )
            while nPos > nNewPos
               if nTop + nPos - nAtTop <= nBottom
                  ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
               endif
               nPos--
            ENDDO
            ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .T., nNumCols, nPos )
            DispEnd()
         endif

      CASE ( bAction := SetKey( nKey ) ) <> NIL
         Eval( bAction, ProcName( 1 ), ProcLine( 1 ), "" )
         if NextKey() == 0
            hb_keySetLast( 255 )
            nKey := 0
         endif

         nRowsClr := Min( nNumRows, nItems )
         if ( nMode := ::Ach_Limits( @nFrstItem, @nLastItem, @nItems, alSelect, ::aTodos ) ) == 4
            nPos := 0
            nAtTop := Max( 1, nPos - nNumRows + 1 )
         else
            while nPos < nLastItem .AND. ! ::Ach_Select( alSelect, nPos )
               nPos++
            ENDDO

            if nPos > nLastItem
               nPos := Min( Max( nFrstItem, nPos ), nLastItem )
            endif

            nAtTop := Min( nAtTop, nPos )
            if nAtTop + nNumRows - 1 > nItems
               nAtTop := Min( Max( 1, nPos - nNumRows + 1 ), nItems - nNumRows + 1 )
            endif

            if nAtTop < 1
               nAtTop := 1
            endif
         endif


         ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems, nRowsClr )

      CASE ( nKey == 27 .OR. nMode == 4 ) .AND. ! lUserFunc

         if nPos <> 0
            ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, .T., .F., nNumCols, nPos )
         endif

         nMode     := 0
         nPos      := 0
         lFinished := .T.

      CASE nKey == 1006 .OR. nKey == 1002
         nAux := HitTest( nTop, nLeft, nBottom, nRight, MRow(), MCol() )
         if nAux <> 0 .AND. ( nNewPos := nAtTop + nAux - 1 ) <= nItems
            if ::Ach_Select( alSelect, nNewPos )
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
               nPos := nNewPos
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .T., nNumCols, nPos )
               if nKey == 1006
                  hb_keyIns( 13 )
               endif
            endif
         endif




      CASE nKey == 5 .OR. nKey == 1014

            nNewPos := nPos - 1
            if nNewPos < nFrstItem
                nPos    := nLastItem
                nAtTop  := Max( 1, nPos - nNumRows + 1 )
                nNewPos := nPos
                ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
                nMode   := 2
            endif

            while ! ::Ach_Select( alSelect, nNewPos )
               nNewPos--
            ENDDO
            if ( nNewPos >= nAtTop .AND. nNewPos <= nAtTop + nNumRows - 1 )
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
               nPos := nNewPos
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .T., nNumCols, nPos )
            else
               DispBegin()
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
               hb_Scroll( nTop, nLeft, nBottom, nRight, nNewPos - ( nAtTop + nNumRows - 1 ) )
               nAtTop := nNewPos
               nPos   := Max( nPos, nAtTop + nNumRows - 1 )
               while nPos > nNewPos
                  if nTop + nPos - nAtTop <= nBottom
                     ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
                  endif
                  nPos--
               ENDDO
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .T., nNumCols, nPos )
               DispEnd()
            endif




      CASE nKey == 24 .OR. nKey == 1015



            nNewPos := nPos + 1
                if nNewPos > nLastItem
                    nPos    := nFrstItem
                    nAtTop  := nPos
                    nNewPos := nPos
                    ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
                    nMode   := 1
                endif

            while ! ::Ach_Select( alSelect, nNewPos )
               nNewPos++
            ENDDO

            if ( nNewPos >= nAtTop .AND. nNewPos <= nAtTop + nNumRows - 1 )
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
               nPos := nNewPos
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .T., nNumCols, nPos )
            else
               DispBegin()
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
               hb_Scroll( nTop, nLeft, nBottom, nRight, nNewPos - ( nAtTop + nNumRows - 1 ) )
               nAtTop := nNewPos - nNumRows + 1
               nPos   := Max( nPos, nAtTop )
               while nPos < nNewPos
                  ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
                  nPos++
               ENDDO
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .T., nNumCols, nPos )
               DispEnd()
            endif



      CASE nKey == 31 .OR. ( nKey == 1 .AND. ! lUserFunc )

         if nPos == nFrstItem
                if lPageCircular
                    nPos    := nLastItem
                    nAtTop  := Max( 1, nPos - nNumRows + 1 )
                    nNewPos := nPos
                    ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
                    nMode   := 2
                else
                    if nAtTop == Max( 1, nPos - nNumRows + 1 )
                        nMode := 1
                    else
                        nAtTop := Max( 1, nPos - nNumRows + 1 )
                        ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
                    endif
                endif
         else
            nPos   := nFrstItem
            nAtTop := nPos
            ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
         endif

      CASE nKey == 30 .OR. ( nKey == 6 .AND. ! lUserFunc )

         if nPos == nLastItem
                if lPageCircular
                    nPos    := nFrstItem
                    nAtTop  := nPos
                    nNewPos := nPos
                    ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
                    nMode   := 1
                else
                    if nAtTop == Min( nLastItem, nItems - Min( nItems, nNumRows ) + 1 )
                        nMode   := 1
                        nMode := 2
                    else
                        nAtTop := Min( nLastItem, nItems - nNumRows + 1 )
                        ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
                    endif
                endif
         else
            if ( nLastItem >= nAtTop .AND. nLastItem <= nAtTop + nNumRows - 1 )
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
               nPos := nLastItem
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .T., nNumCols, nPos )
            else
               nPos   := nLastItem
               nAtTop := Max( 1, nPos - nNumRows + 1 )
               ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
            endif
         endif

      CASE nKey == 29

         if nPos == nFrstItem
            if nAtTop == Max( 1, nPos - nNumRows + 1 )
               nMode := 1
            else
               nAtTop := Max( 1, nPos - nNumRows + 1 )
               ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
            endif
         else
            nNewPos := nAtTop
            while ! ::Ach_Select( alSelect, nNewPos )
               nNewPos++
            ENDDO
            if nNewPos <> nPos
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
               nPos := nNewPos
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .T., nNumCols, nPos )
            endif
         endif

      CASE nKey == 23

         if nPos == nLastItem
            if nAtTop == Min( nPos, nItems - Min( nItems, nNumRows ) + 1 ) .OR. nPos == nItems
               nMode := 2
            else
               nAtTop := Min( nPos, nItems - nNumRows + 1 )
               ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
            endif
         else
            nNewPos := Min( nAtTop + nNumRows - 1, nItems )
            while ! ::Ach_Select( alSelect, nNewPos )
               nNewPos--
            ENDDO
            if nNewPos <> nPos
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
               nPos := nNewPos
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .T., nNumCols, nPos )
            endif
         endif

      CASE nKey == 18

         if nPos == nFrstItem
                if lPageCircular
                    nPos    := nLastItem
                    nAtTop  := Max( 1, nPos - nNumRows + 1 )
                    nNewPos := nPos
                    ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
                    nMode   := 2
                else
                    nMode := 1
                    if nAtTop > Max( 1, nPos - nNumRows + 1 )
                        nAtTop := Max( 1, nPos - nNumRows + 1 )
                        ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
                    endif
                endif
         else
            if ( nFrstItem >= nAtTop .AND. nFrstItem <= nAtTop + nNumRows - 1 )

               nPos   := nFrstItem
               nAtTop := Max( nPos - nNumRows + 1, 1 )
            else
               if ( nPos - nNumRows + 1 ) < nFrstItem
                  nPos   := nFrstItem
                  nAtTop := nFrstItem
               else
                  nPos   := Max( nFrstItem, nPos - nNumRows + 1 )
                  nAtTop := Max( 1, nAtTop - nNumRows + 1 )
                  while nPos > nFrstItem .AND. ! ::Ach_Select( alSelect, nPos )
                     nPos--
                     nAtTop--
                  ENDDO
                  nAtTop := Max( 1, nAtTop )
                  if nAtTop < nNumRows .AND. nPos < nNumRows
                     nPos := nNumRows
                     nAtTop := 1
                  endif
               endif
            endif
            ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
         endif

      CASE nKey == 3

         if nPos == nLastItem
                if lPageCircular
                    nPos    := nFrstItem
                    nAtTop  := nPos
                    nNewPos := nPos
                    ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
                    nMode   := 1
                else
                    nMode := 2
                    if nAtTop < Min( nPos, nItems - nNumRows + 1 )
                        nAtTop := Min( nPos, nItems - nNumRows + 1 )
                        ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
                    endif
                endif
         else
            if ( nLastItem >= nAtTop .AND. nLastItem <= nAtTop + nNumRows - 1 )

               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
               nPos := nLastItem
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .T., nNumCols, nPos )
            else
               nGap := nPos - nAtTop
               nPos := Min( nLastItem, nPos + nNumRows - 1 )
               if ( nPos + nNumRows - 1 ) > nLastItem

                  nAtTop := nLastItem - nNumRows + 1
                  nPos   := Min( nLastItem, nAtTop + nGap )
               else

                  nAtTop := nPos - nGap
               endif

               while nPos < nLastItem .AND. ! ::Ach_Select( alSelect, nPos )
                  nPos++
                  nAtTop++
               ENDDO

               while ( nAtTop + nNumRows - 1 ) > nItems
                  nAtTop--
               ENDDO
               ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
            endif
         endif

      CASE nKey == 13 .AND. ! lUserFunc

         if nPos <> 0
            ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, .T., .F., nNumCols, nPos )
         endif

         nMode     := 0
         lFinished := .T.

      CASE nKey == 4 .AND. ! lUserFunc

         if nPos <> 0
            ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, .T., .F., nNumCols, nPos )
         endif

         nPos      := 0
         lFinished := .T.

      CASE nKey == 19 .AND. ! lUserFunc

         if nPos <> 0
            ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, .T., .F., nNumCols, nPos )
         endif

         nPos      := 0
         lFinished := .T.


      CASE ( ! lUserFunc .OR. nMode == 3 ) .AND.  ! ( cKey := Upper( hb_keyChar( nKey ) ) ) == ""


         FOR nNewPos := nPos + 1 TO nItems
            if ::Ach_Select( alSelect, nNewPos ) .AND. LeftEqI( ::aTodos[ nNewPos ], cKey )
               EXIT
            endif
         NEXT
         if nNewPos == nItems + 1
            FOR nNewPos := 1 TO nPos - 1
               if ::Ach_Select( alSelect, nNewPos ) .AND. LeftEqI( ::aTodos[ nNewPos ], cKey )
                  EXIT
               endif
            NEXT
         endif

         if nNewPos <> nPos
            if ( nNewPos >= nAtTop .AND. nNewPos <= nAtTop + nNumRows - 1 )

               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .F., nNumCols, nPos )
               nPos := nNewPos
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, ::Ach_Select( alSelect, nPos ), .T., nNumCols, nPos )
            else

               nPos   := nNewPos
               nAtTop := Min( Max( 1, nPos - nNumRows + 1 ), nItems )
               ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
            endif
         endif

         nMode := 0

      CASE nMode == 3
           nPos := ::CurElemento

         nMode := 0

        CASE nMode == 10
            nPos := ::CurElemento
            if nPos <> 0
                ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, .T., .F., nNumCols, nPos )
         endif
            nMode := 0

      CASE nMode <> 4
         nMode := iif( nKey == 0, 0, 3 )

      ENDCASE

      if lUserFunc
         if HB_ISNUMERIC( nUserFunc := Do( xUserFunc, nMode, nPos, nPos - nAtTop ) )

            SWITCH nUserFunc
            CASE 0
                    lFinished := .T.
                    nPos      := 0
               EXIT

                CASE 10
                    if ::CurElemento == nLastItem
                         ::CurElemento--
                         nLastItem := ::CurElemento
                    endif
                    nPos := ::CurElemento
                    if nPos <> 0
                        ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, .T., .F., nNumCols, nPos )
                    endif
                    lFinished := .F.
               LOOP

                CASE 4
               if nPos <> 0

                  ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, .T., .F., nNumCols, nPos )
               endif
               lFinished := .T.
               nPos      := 0
               EXIT
            CASE 1
               if nPos <> 0
                  ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, .T., .F., nNumCols, nPos )
               endif
               lFinished := .T.
               EXIT
            CASE 2

                    nMode := 0
               EXIT
            CASE 3


               nMode := 3
               EXIT
            ENDSWITCH

            if nPos > 0 .AND. nMode <> 3







               if ( nMode := ::Ach_Limits( @nFrstItem, @nLastItem, @nItems, alSelect, ::aTodos ) ) == 4
                  nPos := 0
                  nAtTop := Max( 1, nPos - nNumRows + 1 )
               else
                  while nPos < nLastItem .AND. ! ::Ach_Select( alSelect, nPos )
                     nPos++
                  ENDDO

                  if nPos > nLastItem
                     nPos := Min( Max( nFrstItem, nPos ), nLastItem )
                  endif

                  nAtTop := Min( nAtTop, nPos )

                  if nAtTop + nNumRows - 1 > nItems
                     nAtTop := Min( Max( 1, nPos - nNumRows + 1 ), nItems - nNumRows + 1 )
                  endif

                  if nAtTop < 1
                     nAtTop := 1
                  endif
               endif

               ::DispPage( ::aTodos, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nItems )
            endif
         else
            if nPos <> 0
               ::Displine( ::aTodos[ nPos ], nTop + nPos - nAtTop, nLeft, .T., .F., nNumCols, nPos )
            endif
            nPos      := 0
            lFinished := .T.
         endif
      endif
   ENDDO
   SetCursor( nSaveCsr )
   return nPos

static FUNCTION TReceposi_HitTest( nTop, nLeft, nBottom, nRight, mRow, mCol ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi




    if mCol >= nLeft  .AND.  mCol <= nRight .AND.  mRow >= nTop   .AND.  mRow <= nBottom
      return mRow - nTop + 1
    endif
   return 0

static FUNCTION TReceposi_DispPage( acItems, alSelect, nTop, nLeft, nRight, nNumRows, nPos, nAtTop, nArrLen, nRowsClr ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

   LOCAL nCntr
   LOCAL nRow
   LOCAL nIndex

   hb_default( @nRowsClr, nArrLen )

   DispBegin()
   for nCntr := 1 TO Min( nNumRows, nRowsClr )
      nRow   := nTop + nCntr - 1
      nIndex := nCntr + nAtTop - 1

      if ( nIndex >= 1 .AND. nIndex <= nArrLen )
         ::Displine( ::aTodos[ nIndex ], nRow, nLeft, ::Ach_Select( alSelect, nIndex ), nIndex == nPos, nRight - nLeft + 1, nIndex )
      else
         ColorSelect( 0 )
         hb_DispOutAt( nRow, nLeft, Space( nRight - nLeft + 1 ) )
      endif
   next
   DispEnd()
   return self


static FUNCTION TReceposi_Displine( cLine, nRow, nCol, lSelect, lHiLite, nNumCols, nCurElemento ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    nSetColor( ::Color_pFore[nCurElemento], ::Color_pBack[nCurElemento], ::Color_pUns[nCurElemento])
    ColorSelect( iif( lSelect .AND. HB_ISSTRING( cLine ), iif( lHiLite, 1, 0 ), 4 ))
    hb_DispOutAt( nRow, nCol, iif(HB_ISSTRING(cLine), PadR(cLine, nNumCols), Space(nNumCols)))
   if lHiLite
      SetPos( nRow, nCol )
   endif
   ColorSelect( 0 )
   return self


static FUNCTION TReceposi_Ach_Limits( nFrstItem, nLastItem, nItems, alSelect, acItems ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

   LOCAL nCntr

    nFrstItem := nLastItem := nItems := 0
   for nCntr := 1 TO Len( ::aTodos )
      if HB_ISSTRING( ::aTodos[ nCntr ] ) .AND. Len( ::aTodos[ nCntr ] ) > 0
         nItems++
         if ::Ach_Select( alSelect, nCntr )
            if nFrstItem == 0
               nFrstItem := nLastItem := nCntr
            else
               nLastItem := nItems
            endif
         endif
      else
         exit
      endif
   next

   if nFrstItem == 0
      nLastItem := nItems
      return 4
   endif
   return 0


static FUNCTION TReceposi_Ach_Select( alSelect, nPos ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

   LOCAL sel

   if nPos >= 1 .AND. nPos <= Len( alSelect )
      sel := alSelect[ nPos ]
      if HB_ISEVALITEM( sel )
         sel := Eval( sel )
      elseif HB_ISSTRING( sel ) .AND. ! Empty( sel )
         sel := Eval( hb_macroBlock( sel ) )
      endif
      if HB_ISLOGICAL( sel )
         return sel
      endif
   endif
   return .T.


static FUNCTION TReceposi_LeftEqI( string, cKey ) ; local Self AS CLASS TReceposi := QSelf() AS CLASS TReceposi

    LOCAL nLen := Len( cKey )
    return( iif(Left(string, nLen ) == cKey, .T. , .F.))
