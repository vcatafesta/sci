#line 12 "c:\sci\include\rddName.ch"
    EXTERNAL leto
    EXTERNAL DBFNTX
   EXTERNAL DBFCDX


    EXTERNAL DBFFPT
    EXTERNAL SIXCDX
    EXTERNAL DBFNSX
    EXTERNAL HB_MEMIO
#line 5 "tini.prg"
_HB_CLASS TIni ; function TIni ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TIni", iif( .F., { }, { @HBObject() } ), @TIni() ) ) ;
    nScope := 1 ; ( ( nScope ) )
        _HB_MEMBER { File } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"File"}, .F. )
        _HB_MEMBER { Handle } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Handle"}, .F. )
        _HB_MEMBER { Aberto } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Aberto"}, .F. )
        _HB_MEMBER { Separador } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Separador"}, .F. )
        _HB_MEMBER { Ferror } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Ferror"}, .F. )
        _HB_MEMBER { FileExist } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"FileExist"}, .F. )
        _HB_MEMBER { WriteOpen } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"WriteOpen"}, .F. )
        _HB_MEMBER { WriteCount } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"WriteCount"}, .F. )
    nScope := 1 ; ( ( nScope ) )
        _HB_MEMBER New(); oClass:AddMethod( "New", @TIni_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER ReadBool(); oClass:AddMethod( "ReadBool", @TIni_ReadBool(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER ReadInteger(); oClass:AddMethod( "ReadInteger", @TIni_ReadInteger(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER ReadString(); oClass:AddMethod( "ReadString", @TIni_ReadString(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER ReadDate(); oClass:AddMethod( "ReadDate", @TIni_ReadDate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER WriteIni(); oClass:AddMethod( "WriteIni", @TIni_WriteIni(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER Close(); oClass:AddMethod( "Close", @TIni_Close(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER Open(); oClass:AddMethod( "Open", @TIni_Open(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER ShowVar(); oClass:AddMethod( "ShowVar", @TIni_ShowVar(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

        _HB_MEMBER Write(); oClass:AddMethod( "Write", @TIni_WriteIni(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER WriteBool(); oClass:AddMethod( "WriteBool", @TIni_WriteIni(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER WriteInteger(); oClass:AddMethod( "WriteInteger", @TIni_WriteIni(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER WriteString(); oClass:AddMethod( "WriteString", @TIni_WriteIni(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER WriteDate(); oClass:AddMethod( "WriteDate", @TIni_WriteIni(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER Free(); oClass:AddMethod( "Free", @TIni_Close(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
        _HB_MEMBER Create(); oClass:AddMethod( "Create", @TIni_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TIni ;

static FUNCTION TIni_ShowVar( ) ; local Self AS CLASS TIni := QSelf() AS CLASS TIni













    return self


static FUNCTION TIni_New( cFile ) ; local Self AS CLASS TIni := QSelf() AS CLASS TIni

    ::File      := cFile
    ::Separador := ";"
    if RAT( ".", ::File ) == 0
        ::File := UPPER( ltrim(rtrim(cFile))) + ".INI"
    endif
    ::Open()

    return self

static FUNCTION TIni_Close( ) ; local Self AS CLASS TIni := QSelf() AS CLASS TIni

    ms_swap_fclose(::Handle)
    ::Ferror := ms_swap_ferror()
    ::Aberto := .F.
    return( ::Ferror == 0 )

static FUNCTION TIni_Open( ) ; local Self AS CLASS TIni := QSelf() AS CLASS TIni


    if (::Handle := ms_swap_fopen( ::File, 2 + 64) ) == ( -1 )
        ::Ferror := ms_swap_ferror()
    endif

    if ::Ferror == 2 .OR. !(ms_swap_file(::File))
        ::Handle := ms_swap_Fcreate( ::File, 0 )
        ::Ferror := ms_swap_ferror()
    endif
    ::FileExist := ms_swap_file(::File)
    ::Aberto    := .T.
    return(::Aberto)

static FUNCTION TIni_WriteIni( cSection, cKey, xValue ) ; local Self AS CLASS TIni := QSelf() AS CLASS TIni















    LOCAL lRetCode,          cType,             cOldValue,         cNewValue,         cBuffer,           nFileLen,          nSecStart,         nSecEnd,           nSecLen,           cSecBuf,           nKeyStart,         nKeyEnd,           nKeyLen,           lProceed,          cChar

    if LEFT( cSection, 1 ) <> "["
        cSection := "[" + cSection
    endif

    if RIGHT( cSection, 1 ) <> "]"
        cSection += "]"
    endif

    lProceed := lRetCode := .F.
    nSecLen  := 0
    cType    := VALTYPE( xValue )
    DO CASE
        CASE cType == "C"
            cNewValue := xValue
        CASE cType == "N"
            cNewValue := ltrim(rtrim(STR( xValue )))
        CASE cType == "L"
            cNewValue := if( xValue, "1", "0" )
        CASE cType == "D"
            cNewValue := DTOS( xValue )
        OTHERWISE
            cNewValue := ""
    ENDCASE
    if !(::Aberto)
        ::Open()
        ::Aberto := .T.
    endif
    if ::Handle > 0
        ::WriteOpen++
        nFileLen := ms_swap_fseek( ::Handle, 0, 2 )
        ms_swap_fseek( ::Handle, 0 , 0 )
        cBuffer := Space( nFileLen )
        if ms_swap_fread( ::Handle, @cBuffer, nFileLen ) == nFileLen
            nSecStart := AT( cSection, cBuffer )
            if nSecStart > 0
                nSecStart += LEN( cSection ) + 2
                cSecBuf   := RIGHT( cBuffer, nFileLen - nSecStart + 1 )
                if !EMPTY( cSecBuf )
                    nSecEnd := AT( "[", cSecBuf )
                    if nSecEnd > 0
                        cSecBuf := LEFT( cSecBuf, nSecEnd - 1 )
                    endif
                    nSecLen   := LEN( cSecBuf )
                    nKeyStart := AT( cKey, cSecBuf )
                    if nKeyStart > 0
                        nKeyStart += LEN( cKey ) + 1
                        nKeyEnd   := nKeyStart
                        cOldValue := cChar := ""
                        while cChar <> CHR(13)
                            cChar := SUBSTR( cSecBuf, nKeyEnd, 1 )
                            if cChar <> CHR(13)
                                cOldValue += cChar
                                ++ nKeyEnd
                            endif
                        enddo
                        nKeyLen  := LEN( cOldValue )
                        cSecBuf  := STUFF( cSecBuf, nKeyStart, nKeyLen, cNewValue )
                        lProceed := .T.
                    else
                        cSecBuf  := cKey + "=" + cNewValue + CHR(13) + CHR(10) + cSecBuf
                        lProceed := .T.
                    endif
                endif
            else
                cSecBuf  := cSection + CHR(13) + CHR(10) + cKey + "=" + cNewValue + CHR(13) + CHR(10) + CHR(13) + CHR(10)
                lProceed := .T.
            endif
        endif
        if lProceed
            if nSecStart == 0
                nSecStart := LEN( cBuffer )
            endif
            cBuffer := STUFF( cBuffer, nSecStart, nSecLen, cSecBuf )
            ms_swap_fseek( ::Handle, 0 , 0 )






            if ms_swap_fwrite( ::Handle, cBuffer ) == LEN( cBuffer )
                ::WriteCount++
                lRetCode := .T.
            endif
        endif
    endif

    return lRetCode

static FUNCTION TIni_ReadString( cSection, cKey, cDefault, nPos ) ; local Self AS CLASS TIni := QSelf() AS CLASS TIni

    LOCAL cString, cBuffer, nFileLen, nSecPos
    LOCAL cSecBuf, nKeyPos, cChar
    LOCAL xTemp
    LOCAL lRetCode := .F.

    if LEFT( cSection, 1 ) <> "["
        cSection := "[" + cSection
    endif

    if RIGHT( cSection, 1 ) <> "]"
        cSection += "]"
    endif

    if cDefault == NIL
        cDefault := ""
    endif

    cString := cDefault
    if !(::Aberto)
        ::Open()
        ::Aberto := .T.
    endif

    if ::Handle > 0
        nFileLen := ms_swap_fseek(::Handle, 0, 2 )
        ms_swap_fseek( ::Handle, 0 , 0 )
        cBuffer := SPACE( nFileLen )
        if ms_swap_fread( ::Handle, @cBuffer, nFileLen ) == nFileLen
            nSecPos := AT( cSection, cBuffer )
            if nSecPos > 0
                cSecBuf := RIGHT( cBuffer, nFileLen - ( nSecPos + LEN( cSection )))
                if !EMPTY( cSecBuf )
                    nSecPos := AT( "[", cSecBuf )
                    if nSecPos > 0
                        cSecBuf := LEFT( cSecBuf, nSecPos - 1 )
                    endif
                    nKeyPos := AT( cKey, cSecBuf )
                    if nKeyPos > 0
                        nKeyPos += LEN( cKey ) + 1
                        cString := cChar := ""
                        while cChar <> CHR(13)
                            cChar := SUBSTR( cSecBuf, nKeyPos, 1 )
                            if cChar <> CHR(13)
                                cString += cChar
                                ++ nKeyPos
                            endif
                        ENDDO
                    endif
                endif
            endif
        endif

    endif
    if nPos = NIL .OR. nPos = 0
        lRetCode := .T.
        return cString
    else
        xTemp := StrExtract( cString, ::Separador, nPos )
        if Empty( xTemp )
            return( cDefault )
        endif
        return( xTemp )
    endif

static FUNCTION TIni_ReadBool( cSection, cKey, lDefault, nPos ) ; local Self AS CLASS TIni := QSelf() AS CLASS TIni

    LOCAL cValue, cDefault, nValue

    if lDefault == NIL
        lDefault := .F.
    endif
    cValue   := ::ReadString( cSection, cKey, nPos )
    if EMPTY( cValue )
        return( lDefault )
    endif
    return ( nValue := VAL( cValue )) == 1

static FUNCTION TIni_ReadDate( cSection, cKey, dDefault, nPos ) ; local Self AS CLASS TIni := QSelf() AS CLASS TIni

    LOCAL cDateFmt, cValue, cDefault, dDate

    if VALTYPE( dDefault ) <> "D"
        dDefault := CTOD( "" )
    endif
    dDate    := dDefault
    cDefault := ltrim(rtrim(DTOS( dDefault )))
    cValue   := ::ReadString( cSection, cKey, cDefault, nPos )
    if !EMPTY( cValue )
        dDate := CTOD( cValue )
        if EMPTY( dDate )
            cDateFmt := LETO_SET( 4, "mm/dd/yy" )
            dDate := CTOD( SUBSTR( cValue, 5, 2 ) + "/" + RIGHT( cValue, 2 ) + "/" + LEFT( cValue, 4 ))
            LETO_SET( 4, cDateFmt )
        endif
    endif
    return dDate


static FUNCTION TIni_ReadInteger( cSection, cKey, nDefault, nPos ) ; local Self AS CLASS TIni := QSelf() AS CLASS TIni

    LOCAL cValue, cDefault, nValue

    if nDefault == NIL
        nDefault := 0
    endif
    nValue   := nDefault
    cDefault := ltrim(rtrim(STR( nDefault )))
    cValue   := ::ReadString( cSection, cKey, cDefault, nPos )
    if !EMPTY( cValue )
        nValue := VAL( cValue )
    endif
    return nValue

Function TIniNew( cFile )

    return( TIni():New( cFile ))
