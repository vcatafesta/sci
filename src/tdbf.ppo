#line 12 "c:\sci\include\rddName.ch"
    EXTERNAL leto
    EXTERNAL DBFNTX
   EXTERNAL DBFCDX


    EXTERNAL DBFFPT
    EXTERNAL SIXCDX
    EXTERNAL DBFNSX
    EXTERNAL HB_MEMIO
#line 3 "tdbf.prg"
EXTERNAL HB_LANG_EN
EXTERNAL HB_LANG_PT

function AmbienteTDbf(cDbf)
    PUBLIC oAmbiente := TAmbiente():New()
    PUBLic oIndice      := TIndiceNew()
    PUBLIC oMenu     := oAmbiente
    PUBLIC oIni       := TIniNew("TDBF.INI")
    PUBL aLpt1          := {}
    PUBL aLpt2          := {}
    PUBL aLpt3          := {}

    Scroll() ; SetPos( 0, 0 )
    oAmbiente:LetoIp   := "//127.0.0.1"
    oAmbiente:LetoPort := "2812"
    oIndice:ProgressoNtx := .T.
    FechaTudo()
    if !AbreArquivo(cDbf)
        __quit()
    endif
    if !AbreArquivo("USUARIO")
        __quit()
    endif
    if !AbreArquivo("PRINTER")
        __quit()
    endif

    Fechatudo()
    return

function MainTDbf()
   LOCAL e1
   LOCAL e2
   LOCAL e3
   LOCAL e4
    LOCAL oDbf
    LOCAL cDbf := "RECEBER"

    hb_langSelect("pt")
    AmbienteTDbf(cDbf)
    oDbf := TDbf():New(cDbf)
    oMenu:Limpa()




    alertaPy(" INFO: Nada encontrado nos parametros informados abaixo: ;-;;" +     " Fatura: " + "000" + ";" +     " Codigo: " + "000" + ";" +     "  Busca: " + "000" + ";" +     "   Data: " + dToc(Date()), 31 , .F.)
    pausetdbf()

    WITH OBJECT oDbf
        QOut( "oDbf:DBF        =>", :dbf )
        QOut( "oDbf:Alias      =>", :Alias )
        QOut( "oDbf:Travados() =>", :Travados() )

        QOut( "oDbf:aaField    =>", :addField() )
        QOut( "oDbf:Field      =>", len(:Field) )

        pausetdbf()
        HSetCaseMatch( :Field,  .F. )



















































        Scroll() ; SetPos( 0, 0 )







































        while( .T. )
            setcolor("")
            Scroll() ; SetPos( 0, 0 )

            :FieldBlank()
            :Field["CODI"]["VALUE"] := :ProxReg("CODI")
            AlertaPy("Ooops!: Entre com o Codigo!",nil,nil,.F.)
            MaBox(09, 09, 18, 100, "INCLUSAO DE CLIENTES")
            SetCursor(1) ; DevPos( 11, 11 ) ; DevOut( ':Field["CODI" ]["VALUE"] ' ) ; SetCursor(1) ; SetPos( Row(), Col()+1 ) ; AAdd( GetList, _GET_( :Field["CODI"]["VALUE"], ':Field["CODI"]["VALUE"]',, {|| if(Empty(:Field["CODI"]["VALUE"]), ( ErrorBeep(), AlertaPy("Ooops!, Entre com o Codigo", nil, nil, ), .F. ), .T. )},))
            SetCursor(1) ; DevPos( 12, 11 ) ; DevOut( ':Field["NOME" ]["VALUE"] ' ) ; SetCursor(1) ; SetPos( Row(), Col()+1 ) ; AAdd( GetList, _GET_( :Field["NOME"]["VALUE"], ':Field["NOME"]["VALUE"]',, {|| if(Empty(:Field["NOME"]["VALUE"]), ( ErrorBeep(), AlertaPY("Ooops!, Entre com o Nome!"), .F. ), .T. )},))
            SetCursor(1) ; DevPos( 13, 11 ) ; DevOut( ':Field["ENDE" ]["VALUE"] ' ) ; SetCursor(1) ; SetPos( Row(), Col()+1 ) ; AAdd( GetList, _GET_( :Field["ENDE"]["VALUE"], ':Field["ENDE"]["VALUE"]',, {|| if(Empty(:Field["ENDE"]["VALUE"]), ( ErrorBeep(), AlertaPy("Ooops!, Entre com o Ende!"), .F. ), .T. )},))
            SetCursor(1) ; DevPos( 14, 11 ) ; DevOut( ':Field["CIDA" ]["VALUE"] ' ) ; SetCursor(1) ; SetPos( Row(), Col()+1 ) ; AAdd( GetList, _GET_( :Field["CIDA"]["VALUE"], ':Field["CIDA"]["VALUE"]',, {|| if(Empty(:Field["CIDA"]["VALUE"]), ( ErrorBeep(), AlertaPy("Ooops!, Entre com o Codigo!"), .F. ), .T. )},))
            SetCursor(1) ; DevPos( 15, 11 ) ; DevOut( ':Field["DATA" ]["VALUE"] ' ) ; SetCursor(1) ; SetPos( Row(), Col()+1 ) ; AAdd( GetList, _GET_( :Field["DATA"]["VALUE"], ':Field["DATA"]["VALUE"]',, {|| if(Empty(:Field["DATA"]["VALUE"]), ( ErrorBeep(), AlertaPy("Ooops!, Entre com o Codigo!"), .F. ), .T. )},))
            SetCursor(1) ; DevPos( 16, 11 ) ; DevOut( ':Field["MEDIA"]["VALUE"] ' ) ; SetCursor(1) ; SetPos( Row(), Col()+1 ) ; AAdd( GetList, _GET_( :Field["MEDIA"]["VALUE"], ':Field["MEDIA"]["VALUE"]',, {|| if(Empty(:Field["MEDIA"]["VALUE"]), ( ErrorBeep(), AlertaPy("Ooops!, Entre com o Codigo!"), .F. ), .T. )},))
            ReadModal( GetList, NIL,,,,, ) ; GetList := {} ; ( GetList )
            if lastkey() = 27
                if conf("Pegunta: Encerrar?")
                    :FieldBlank()
                    exit
                endif
                loop
            endif
            QOut( ':Field["CODI"]["VALUE"]', :Field["CODI"]["VALUE"] )
            QOut( ':Field["NOME"]["VALUE"]', :Field["NOME"]["VALUE"] )
            QOut( ':Field["ENDE"]["VALUE"]', :Field["ENDE"]["VALUE"] )
            QOut( ':Field["CIDA"]["VALUE"]', :Field["CIDA"]["VALUE"] )
            QOut( ':Field["DATA"]["VALUE"]', :Field["DATA"]["VALUE"] )
            QOut( ':Field["MEDIA"]["VALUE"]', :Field["MEDIA"]["VALUE"] )
            if conf("Pegunta: Deseja Salvar?")
                :CommitNew()
            endif
            browse()
        enddo
    ENDWITH
    oDbf:Destroy()
    __quit()
    return nil

function pausetdbf()
    inkey(0)
    if lastkey() = 27
       __quit()
    endif
    retur nil

_HB_CLASS TDbf ; function TDbf ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TDbf", iif( .F., { }, { @HBObject() } ), @TDbf() ) ) ;
   _HB_MEMBER { Id } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Id"}, .F. )
    _HB_MEMBER { Field } ; oClass:AddMultiData(, {=>}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Field"}, .F. )
    _HB_MEMBER { hField } ; oClass:AddMultiData(, {=>}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hField"}, .F. )
    _HB_MEMBER { hStru } ; oClass:AddMultiData(, {=>}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hStru"}, .F. )
    _HB_MEMBER { Dbf } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Dbf"}, .F. )
    _HB_MEMBER { Alias } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Alias"}, .F. )
    _HB_MEMBER { nLastRecnoCommit } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLastRecnoCommit"}, .F. )

    _HB_MEMBER new( cDbf) AS CLASS TDbf; oClass:AddMethod( "new", @TDbf_new(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Destroy(); oClass:SetDestructor( @TDbf_Destroy() )
   _HB_MEMBER Open(); oClass:AddMethod( "Open", @TDbf_Open(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DbSkip( x); oClass:AddMethod( "DbSkip", @TDbf_DbSkip(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DbSeek( x); oClass:AddMethod( "DbSeek", @TDbf_DbSeek(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DbDelete( nrecno); oClass:AddMethod( "DbDelete", @TDbf_DbDelete(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DbDelete( nrecno); oClass:AddMethod( "DbDelete", @TDbf_DbDelete(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Destroy(); oClass:AddMethod( "Destroy", @TDbf_Destroy(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER GetDados(); oClass:AddMethod( "GetDados", @TDbf_GetDados(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Append(); oClass:AddMethod( "Append", @TDbf_Append(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Libera(); oClass:AddMethod( "Libera", @TDbf_Libera(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Travados(); oClass:AddMethod( "Travados", @TDbf_Travados(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER addField(); oClass:AddMethod( "addField", @TDbf_addField(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Fcount(); oClass:AddMethod( "Fcount", @TDbf_Fcount(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DbStruct(); oClass:AddMethod( "DbStruct", @TDbf_DbStruct(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER GetFieldBlank( cType, nLen); oClass:AddMethod( "GetFieldBlank", @TDbf_GetFieldBlank(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER FieldBlank(); oClass:AddMethod( "FieldBlank", @TDbf_FieldBlank(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Commit(); oClass:AddMethod( "Commit", @TDbf_Commit(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER CommitNew(); oClass:AddMethod( "CommitNew", @TDbf_CommitNew(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER RollBack( nLastRecnoCommit); oClass:AddMethod( "RollBack", @TDbf_RollBack(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ProxReg( cCampo); oClass:AddMethod( "ProxReg", @TDbf_ProxReg(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Create( cDbf); oClass:AddMethod( "Create", @TDbf_new(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Init( cDbf); oClass:AddMethod( "Init", @TDbf_new(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Del( nrecno); oClass:AddMethod( "Del", @TDbf_DbDelete(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Delete( nrecno); oClass:AddMethod( "Delete", @TDbf_DbDelete(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Close(); oClass:AddInline( "Close", {|Self| ( ( Self ) ), (::Alias)->(DbCloseArea())}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Recno(); oClass:AddInline( "Recno", {|Self| ( ( Self ) ), (::Alias)->(Recno())}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Order( nindice); oClass:AddInline( "Order", {|Self , nindice| ( ( Self ) ), (::Alias)->(Order(nindice))}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Incluiu(); oClass:AddInline( "Incluiu", {|Self| ( ( Self ) ), (::Alias)->(Incluiu())}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DbGoTop(); oClass:AddInline( "DbGoTop", {|Self| ( ( Self ) ), (::Alias)->(DbGotop())}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DbGoBottom(); oClass:AddInline( "DbGoBottom", {|Self| ( ( Self ) ), (::Alias)->(DbGoBottom())}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER TravaReg(); oClass:AddInline( "TravaReg", {|Self| ( ( Self ) ), (::Alias)->(TravaReg())}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DbGoto( nrecno); oClass:AddInline( "DbGoto", {|Self , nrecno| ( ( Self ) ), (::Alias)->(DbGoto(nrecno))}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )





oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TDbf ;

static FUNCTION TDbf_new( cDbf ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    if cDbf = Nil
        alerta("Inicializacao sem o database")
    endif
    ::Dbf    := upper(cDbf) + ".DBF"
    ::Alias  := upper(cDbf)
    ::Open()
    ::AddField()
    ::DbStruct()

    return self

static FUNCTION TDbf_Destroy( ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    (::Alias)->(DbCloseArea())
   self := nil
    return nil

static function TDbf_Fcount( ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    return (::Alias)->(FCount())

static function TDbf_ProxReg( cCampo ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    LOCAL nRecno := ::Recno()
    LOCAL nPos
    LOCAL nLen
    LOCAL cType
    LOCAL cNewReg

    hb_default(@cCampo, "CODI")
    ::DbGoBottom()
    nPos   := (::Alias)->(FieldPos(cCampo))
    nLen   := (::Alias)->(FieldLen(nPos))
    cType  := (::Alias)->(FieldType(nPos))

    SWITCH cType
        case "C"  ; cNewReg := ltrim(rtrim(strzero(Val((::Alias)->(FieldGet(nPos)))+1, nLen)));     exit
        case "N"  ; cNewReg := (::Alias)->(FieldGet(nPos))+1 ; exit
        case "D"  ; cNewReg := Date() ; exit
        otherwise ; cNewReg := (::Alias)->(FieldGet(nPos)) ; exit
    ENDSWITCH
    ::DbGoto(nRecno)
    return(cNewReg)

static function TDbf_addField( ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
   LOCAL aCampos := {}
   LOCAL aGets   := {}
    LOCAL fLen := ::FCount()
    LOCAL x
    LOCAL cCampo
    LOCAL cGet
    LOCAL cType
    LOCAL nLen
    LOCAL nDec















    hCor   := { "cor"   =>     {"corborda" => {"value" => 0}, "cormenu"  => {"value" => 1}, "corcabec" => {"value" => 2}, "corfundo" => {"value" => 3}, "corbarra" => {"value" => 4}, "cor1"     => {"value" => 5}}}

    for x := 1 To fLen
        cCampo := (::Alias)->(FieldName(x))
        cGet   := (::Alias)->(FieldGet(x))
        cType  := (::Alias)->(FieldType(x))
        nLen   := (::Alias)->(FieldLen(x))
        nDec   := (::Alias)->(FieldDec(x))

        aadd( aCampos, cCampo)
        aadd( aGets, cGet)
        ::Field[cCampo ] := Hash()
        ::Field[cCampo ]["NAME" ] := cCampo
        ::Field[cCampo ]["TYPE" ] := cType
        ::Field[cCampo ]["LEN"  ] := nLen
        ::Field[cCampo ]["DEC"  ] := nDec
        ::Field[cCampo ]["RECNO"] := 0
        ::Field[cCampo ]["VALUE"] := ::GetFieldBlank(cType, nLen)
    next
    ::hField := ::Field
    return len(::Field)

static function TDbf_GetDados( ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    LOCAL x
    LOCAL xLen := ::FCount()
    LOCAL cCampo
    LOCAL cGet
    LOCAL cType
    LOCAL nLen
    LOCAL nDec

    for x := 1 To xLen
        cCampo := (::Alias)->(FieldName(x))
        cGet   := (::Alias)->(FieldGet(x))
        cType  := (::Alias)->(FieldType(x))
        nLen   := (::Alias)->(FieldLen(x))
        nDec   := (::Alias)->(FieldDec(x))
        ::Field[cCampo ]["RECNO"] := ::Recno()
        ::Field[cCampo ]["VALUE"] := cGet
    next
    return len(::Field)

static function TDbf_Commit( ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    LOCAL x
    LOCAL xLen := ::FCount()
    LOCAL cCampo
    LOCAL cGet
    LOCAL cType
    LOCAL nLen
    LOCAL nDec

    if ::TravaReg()
        for x := 1 To xLen
            cCampo := (::Alias)->(FieldName(x))
            cGet   := (::Alias)->(FieldGet(x))
            cType  := (::Alias)->(FieldType(x))
            nLen   := (::Alias)->(FieldLen(x))
            nDec   := (::Alias)->(FieldDec(x))
            (::Alias)->( FieldPut( x, ::Field[cCampo ]["VALUE"]))
        next
        ::Libera()
        return .T.
    endif
    return .F.

static function TDbf_CommitNew( ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    LOCAL x
    LOCAL xLen := ::FCount()
    LOCAL cCampo
    LOCAL cGet
    LOCAL cType
    LOCAL nLen
    LOCAL nDec

    if ::Incluiu()
        for x := 1 To xLen
            cCampo := (::Alias)->(FieldName(x))
            cGet   := (::Alias)->(FieldGet(x))
            cType  := (::Alias)->(FieldType(x))
            nLen   := (::Alias)->(FieldLen(x))
            nDec   := (::Alias)->(FieldDec(x))
            (::Alias)->( FieldPut( x, ::Field[cCampo ]["VALUE"]))
        next
        ::nLastRecnoCommit := ::Recno()
        ::Libera()
        return .T.
    endif
    return .F.

static function TDbf_RollBack( nLastRecnoCommit ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    hb_default(@nLastRecnoCommit, ::nLastRecnoCommit)
    if nLastRecnoCommit <> nil
      return( ::DbDelete(nLastRecnoCommit))
    endif
    return .F.

static function TDbf_GetFieldBlank( cType, nLen ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    LOCAL hBranco := {"C" => Space(nLen), "N" => 0, "D" => cTod("//"), "L" => .F. }
    LOCAL cGet    := hBranco[cType]
    return cGet

static function TDbf_FieldBlank( ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    LOCAL x
    LOCAL xLen := ::FCount()
    LOCAL cCampo
    LOCAL cGet
    LOCAL cType
    LOCAL nLen
    LOCAL nDec

    for x := 1 To xLen
        cCampo := (::Alias)->(FieldName(x))
        cGet   := (::Alias)->(FieldGet(x))
        cType  := (::Alias)->(FieldType(x))
        nLen   := (::Alias)->(FieldLen(x))
        nDec   := (::Alias)->(FieldDec(x))
        ::Field[cCampo ]["RECNO"] := 0
        ::Field[cCampo ]["VALUE"] := ::GetFieldBlank(cType, nLen)
    next
    ::hField := ::Field
    return len(::Field)

static function TDbf_DbStruct( ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    ::hStru := {=>}







    ::hStru[::Alias] := (::Alias)->(DbStruct())
    return len(::hStru)

static FUNCTION TDbf_Open( ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    Scroll() ; SetPos( 0, 0 )
    QOut( ::Alias )
    inkey(0)
    if !UsaArquivo((::Alias))
        MensFecha()
    endif
    ::alias := Alias()
    return self

static FUNCTION TDbf_Travados( ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    LOCAL nRecno
    LOCAL aRecno := (::Alias)->(dbRLockList())

    for EACH nRecNo IN aRecno

    next
    return aRecno

static function TDbf_DbDelete( nrecno ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
   hb_default(@nrecno, ::Recno())
   ::DbGoto(nrecno)
    if (::Alias)->(TravaReg())
        (::Alias)->(DbDelete())
        ::Libera()
        ::DbSkip(0)
        return .T.
   endif
    return .F.

static function TDbf_Append( ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    return((::Alias)->(Incluiu()))

static function TDbf_Libera( ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    (::Alias)->(Libera())
    return self

static FUNCTION TDbf_DbSkip( x ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    (::Alias)->(DbSkip(x))
    ::GetDados()
    return self

static function TDbf_DbSeek( x ) ; local Self AS CLASS TDbf := QSelf() AS CLASS TDbf
    LOCAL lresult := (::Alias)->(DbSeek(x))
    if lresult
        ::GetDados()
    endif
    return lresult

Function TDbfNew(cDbf)

    return( TDbf():New(cDbf))

_HB_CLASS bar ; function bar ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "bar", iif( .F., { }, { @HBObject() } ), @bar() ) ) ;
    _HB_MEMBER { name } ; oClass:AddMultiData(, "BAR", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"name"}, .F. )
oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS bar ;

WITH OBJECT foo():new()
    QOut( :name )
    QOut( :__withobject:name )
    QOut( :__withobject := bar():new() )
    QOut( :name )
ENDWITH

function footeste()
    o := foo():foo:_1()
    o := foo():foo:_2()
    o := foo():foo:_3()

_HB_CLASS foo ; function foo ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "foo", iif( .F., { }, { @HBObject() } ), @foo() ) ) ;
   _HB_MEMBER _1(); oClass:AddMethod( "_1", @foo__1(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER _2(); oClass:AddMethod( "_2", @foo__2(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER _3(); oClass:AddMethod( "_3", @foo__3(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER { name } ; oClass:AddMultiData(, "FOO", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"name"}, .F. )
oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS foo ;

static FUNCTION foo__1( ) ; local Self AS CLASS foo := QSelf() AS CLASS foo
    aHash := {=>}
    aHash["Nome"] := "Jose Manoel"
    aHash["Hoje"] := DATE()
    aHash[Date()] := "Esta chave é uma data"
    aHash[12]     := .T.


    QOut( aHash["Nome"] )
    QOut( aHash["Hoje"] )
    QOut( aHash[date()] )
    QOut( aHash[12] )

    pausetdbf()

static FUNCTION foo__2( ) ; local Self AS CLASS foo := QSelf() AS CLASS foo
    aHash := {=>}
    HSetCaseMatch( aHash, .F. )
    aHash["Nome"] := "Jose Carlos"
    QOut( aHash["nOme"] )
    pausetdbf()


static FUNCTION foo__3( ) ; local Self AS CLASS foo := QSelf() AS CLASS foo
    aHash := {=>}
    HSetCaseMatch( aHash, .F. )
    aHash["Nome"] := "Joao Manoel"
    aHash["Hoje"] := DATE()
    aHash[Date()] := "Chave data"
    aHash[12] := .T.

    FOR i := 1 TO Len( aHash )
        QOut( HGetKeyAt( aHash, i ) )
        QOut( HGetValueAt( aHash, i ) )
    END


    nPos := HGetPos( aHash, "Nome" )
    if nPos <> 0

        QOut( HGetValueAt( aHash, nPos ) )
    End
    pausetdbf()

function TesteNew()
    public oAmbiente := TAmbienteNew()
    Scroll() ; SetPos( 0, 0 )
    a := "A"
   b := "B"
   FOR EACH a, b IN { 1, 2, 3, 4 }, "abcd"
      QOut( a, b )



   NEXT
   QOut( a, b )


   FOR EACH a IN { 1, 2, 3, 4 }
      if a:__enumindex == 3
         QOut( a )
         EXIT
      endif
   NEXT

   arr := { 1, 2, 3 }
   str := "abc"
    QOut( "arr := { 1, 2, 3 }" )
   QOut( 'str := "abc"' )
   QOut( "FOR EACH a, b IN arr, str" )

   FOR EACH a, b IN arr, str
      QOut( "a=>",  a *= 2,     arr[a:__enumindex], a:__enumvalue, a:__enumkey )
        QOut( "b=>",  b := Upper( b ), b:__enumindex,  b:__enumvalue, b:__enumkey )
   NEXT




    hCores := { "Cores" => {0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 }}
    hDays  := { "Days"  => {"Mon", "Tue", "Wed", "Thu", "Fri", "Sat" }}






    hCor   := { "cor"   =>     {"corborda" => {"value" => 0}, "cormenu"  => {"value" => 1}, "corcabec" => {"value" => 2}, "corfundo" => {"value" => 3}, "corbarra" => {"value" => 4}, "cor1"     => {"value" => 5}}}
   myHash := Hash()
   myHash[ "cor" ] := Hash()
   HSetCaseMatch( myHash, .F. )

   myHash[ "cor" ][ "corborda" ] := Hash()
    myHash[ "cor" ][ "corborda" ]["value"] := 0

   myHash[ "cor" ][ "cormenu"  ] := Hash()
    myHash[ "cor" ][ "cormenu"  ]["value"] := 1

   myHash[ "cor" ][ "corcabec" ] := Hash()
    myHash[ "cor" ][ "corcabec" ]["value"] := 2

   myHash[ "cor" ][ "corfundo" ] := Hash()
    myHash[ "cor" ][ "corfundo" ]["value"] := 3

   myHash[ "cor" ][ "corbarra" ] := Hash()
    myHash[ "cor" ][ "corbarra" ]["value"] := 4

    myHash[ "cor" ][ "cor1"     ] := Hash()
    myHash[ "cor" ][ "cor1"     ]["value"] := 5

   QOut( HHasKey( myHash[ "cor" ] , "corborda" ) )
   QOut( HHasKey( myHash[ "cor" ] , "cormenu" ) )

    QOut( myHash[ "COR"]["cormenu"]["value"] )



    HSetCaseMatch( hCor,   .F. )
    HSetCaseMatch( hCores, .F. )
    HSetCaseMatch( hDays,  .F. )

    a := nil
    b := nil
    c := nil
    FOR EACH a IN hDays["Days"]
      QOut( a, hDays["Days"][a:__enumindex], a:__enumvalue, a:__enumkey, a:__enumBase )
   NEXT


    a := nil
    b := nil
    c := nil

    newH := {}


    FOR EACH a IN hCor
        QOut( )
        QOut( )

            FOR EACH b IN a

                FOR EACH c IN b
                        QQOut( a:__enumKey + "." )
                        QQOut( b:__enumKey + "." )
                        QQOut( c:__enumKey + "=" + ltrim(rtrim(c:__enumValue)) )
                        aadd(newH, a:__enumKey + "." + b:__enumKey + "." + ltrim(rtrim(c:__enumValue)))
                next
                QOut( )
            next
   NEXT
    pausetdbf()
    Scroll() ; SetPos( 0, 0 )
    mabox(10,10,20,40)
    achoice(11, 11, 19, 39, newH)
    __quit()

function DemoHb_IsString()

   LOCAL cBigString
   LOCAL cFirst
   LOCAL cString := Space( 20 )

   QOut( Len( cString ) )
   cBigString := Space( 100000 )

   QOut( Len( cBigString ) )
   dbUseArea( .T.,, "receber",, iif( .F. .OR. .F., ! .F., NIL ), .F. )
   cFirst := MakeEmpty( 1 )
   QOut( Len( cFirst ) )
    pausetdbf()

   return

STATIC FUNCTION MakeEmpty( xField )

   LOCAL nRecord
   LOCAL xRetValue

   if ! Alias() == ""
      nRecord := RecNo()
      dbGoto( 0 )
      if HB_ISSTRING( xField )
         xField := AScan( dbStruct(), {| aFields | aFields[ DBS_NAME ] == Upper( xField ) } )
      else
         hb_default( @xField, 0 )
         if xField < 1 .OR. xField > FCount()
            xField := 0
         endif
      endif
      if xField <> 0
         xRetValue := FieldGet( xField )
      endif
      dbGoto( nRecord )
   endif

   return xRetValue
