#line 12 "c:\sci\include\rddName.ch"
    EXTERNAL leto
    EXTERNAL DBFNTX
   EXTERNAL DBFCDX


    EXTERNAL DBFFPT
    EXTERNAL SIXCDX
    EXTERNAL DBFNSX
    EXTERNAL HB_MEMIO
#line 25 "api.prg"
function teste()

    LOCAL ncor := 31
    LOCAL x    := 999
    LOCAL cstr := ms_replicate("=", 80)
    LOCAL cfor := MS_for(100)
    LOCAL ctit := capitalize("Macrosoft api " + ProcName())



    ms_SetConsoleTitle(cTit)
    QOut( cstr )
    QOut( "Api for Win32, Copyright (c) 1991-2018, Vilmar Catafesta" )
    QOut( "Versao Harbour : ", hb_Version(0 ) )
    QOut( "Compiler C++   : ", hb_Version(1) )
    QOut( "Computer       : ", NetName() )
    QOut( cstr )

    QOut( "Len cstr        :", len(cstr) )
    QOut( "Len ncor        :", len(ncor) )
    QOut( "Len x           :", len(x) )
    QOut( "Len .t.         :", len(.T.) )
    QOut( "Len .f.         :", len(.F.) )
    QOut( "Len ms_for(100) :", len(cfor) )
    QOut( "val x           :", val("100") )
    QOut( "val x           :", hb_val("100") )

    QOut( "capitalize      :", capitalize("vilmar catafesta ") )
    QOut( "capitalize      :", len(capitalize("vilmar catafesta ")) )


































    return nil






PROCEDURE PrinterMain()
    Teste1()


PROCEDURE Teste1()
   LOCAL nPrn := 1
   LOCAL cFileName := Space( 40 )
   LOCAL GetList := {}

   LOCAL aPrn := win_printerList()

   Scroll() ; SetPos( 0, 0 )

   if Empty( aPrn )
      Alert( "No printers installed - Cannot continue" )
   else
      while nPrn <> 0
         Scroll() ; SetPos( 0, 0 )
         DevPos( 0, 0 ) ; DevOut( "win_PrintFileRaw() test program. Choose a printer to test" )
         SetCursor(1) ; DevPos( 1, 0 ) ; DevOut( "File name:" ) ; SetCursor(1) ; SetPos( Row(), Col()+1 ) ; AAdd( GetList, _GET_( cFileName, "cFileName", "@!K",,))
         ReadModal( GetList, NIL,,,,, ) ; GetList := {} ; ( GetList )
         DispBox( 2, 0, MaxRow(), MaxCol(), 1 )
         nPrn := AChoice( 3, 1, MaxRow() - 1, MaxCol() - 1, aPrn, .T.,, nPrn )
         if nPrn <> 0
            PrnTest( aPrn[ nPrn ], cFileName )
         endif
      ENDDO
   endif

   return

STATIC PROCEDURE PrnTest( cPrinter, cFileName )

   LOCAL lDelete

   if Empty( cFileName )
      hb_MemoWrit( cFileName := hb_FNameExtSet( "api.prg", ".prn" ), "Hello World!" + Chr( 12 ) )
      lDelete := .T.
   else
      lDelete := .F.
   endif

   Alert( "win_PrintFileRaw() returned: " + hb_ntos( win_PrintFileRaw( cPrinter, cFileName, "testing raw printing" ) ) )

   if lDelete
      FErase( cFileName )
   endif

    Scroll() ; SetPos( 0, 0 )
   Teste2()



PROCEDURE Teste2()

   LOCAL aPrn
   LOCAL nPrn := 1
   LOCAL cDocName := "Raw printing test"
   LOCAL cFileName := Space( 256 )
   LOCAL GetList := {}

   if Empty( aPrn := win_printerList() )
      Alert( "No printers installed - Cannot continue" )
   else
      while nPrn > 0

         Scroll() ; SetPos( 0, 0 )
         DevPos( 0, 0 ) ; DevOut( "Raw printing test. Choose a printer to test" )
         SetCursor(1) ; DevPos( 1, 0 ) ; DevOut( "File name:" ) ; SetCursor(1) ; SetPos( Row(), Col()+1 ) ; AAdd( GetList, _GET_( cFileName, "cFileName", "@KS40",,))
         ReadModal( GetList, NIL,,,,, ) ; GetList := {} ; ( GetList )
         DispBox( 2, 0, MaxRow(), MaxCol(), 1 )

         if ( nPrn := AChoice( 3, 1, MaxRow() - 1, MaxCol() - 1, aPrn, .T.,, nPrn ) ) > 0

            if Empty( cFileName )

               Alert( "win_PrintDataRaw() returned: " +  hb_ntos( win_PrintDataRaw( aPrn[ nPrn ], "Hello World!" + hb_BChar( 12 ), cDocName ) ) )
            else

               Alert( "win_PrintFileRaw() returned: " +  hb_ntos( win_PrintFileRaw( aPrn[ nPrn ], cFileName, cDocName ) ) )
            endif
         endif
      ENDDO
   endif
#line 183 "api.prg"
PROCEDURE Teste3()

   Dump( win_printerList( .F., .F. ) )
   Dump( win_printerList( .F., .T. ) )
   Dump( win_printerList( .T., .F. ) )
   Dump( win_printerList( .T., .T. ) )

   ( OutStd( hb_eol() ), OutStd( "win_printerGetDefault():", ">" + win_printerGetDefault() + "<" ) )
   ( OutStd( hb_eol() ), OutStd( "win_printerStatus():", hb_ntos( win_printerStatus() ) ) )

   return

STATIC PROCEDURE Dump( a )

   LOCAL b, c

   ( OutStd( hb_eol() ), OutStd( "===" ) )
   FOR EACH b IN a
      ( OutStd( hb_eol() ) )
      if HB_ISARRAY( b )
         FOR EACH c IN b
            OutStd( c:__enumIndex(), c )
            if c:__enumIndex() == 2


               OutStd( "",  ">>" + win_printerPortToName( c ) + "<<",  "|>>" + win_printerPortToName( c, .T. ) + "<<|" )
            endif
            ( OutStd( hb_eol() ) )
         NEXT
         ( OutStd( hb_eol() ), OutStd( "---" ) )
      else
         ( OutStd( hb_eol() ), OutStd( b, win_printerExists( b ), win_printerStatus( b ) ) )
      endif
        inkey(0)
   NEXT
   return
#line 223 "api.prg"
PROCEDURE Teste4()

   LOCAL a := win_printerGetDefault()

   ( OutStd( hb_eol() ), OutStd( ">" + a + "<" ) )

   ( OutStd( hb_eol() ), OutStd( win_printerSetDefault( a ) ) )

   return



( OutStd( hb_eol() ), OutStd( WIN_PRINTEREXISTS() ) )
( OutStd( hb_eol() ), OutStd( WIN_PRINTERSTATUS() ) )
( OutStd( hb_eol() ), OutStd( WIN_PRINTERPORTTONAME() ) )
( OutStd( hb_eol() ), OutStd( WIN_PRINTERLIST() ) )
( OutStd( hb_eol() ), OutStd( WIN_PRINTERGETDEFAULT() ) )
( OutStd( hb_eol() ), OutStd( WIN_PRINTERSETDEFAULT() ) )
( OutStd( hb_eol() ), OutStd( WIN_PRINTFILERAW() ) )



Win_PrintFileRaw(Win_PrinterGetDefault(), "REPLACE.PRG", "Relatorio Teste")
Alert( "Retorno: " + hb_ntos( WIN_PRINTFILERAW( cPrinter, "REPLACE.PRG", "testando impress„o" ) ) )

SelecionaImpressora()

Function SelecionaImpressora()
Local aPrinterList := {}, nOpc := 1, lCancel := .F.

aPrinterList := Win_PrinterList()
For nCont = 1 To Len(aPrinterList)
   if aPrinterList[nCont] == Win_PrinterGetDefault()
      nOpc := nCont
      Exit
   endif
Next
Achoice(20,Int(MaxCol()/4), 40, 79, aPrinterList,@nOpc,"Impressora a utilizar")
lCancel := ( LastKey() == 27 )
if ! lCancel
   Win_PrinterSetDefault(aPrinterList[nOpc])
endif
return lCancel


Scroll() ; SetPos( 0, 0 )

( OutStd( hb_eol() ), OutStd( ReplAll("abcd  ", "-") ) )
( OutStd( hb_eol() ), OutStd( ReplAll("001234", " ", "0") ) )
( OutStd( hb_eol() ), OutStd( ReplAll("   d  ", "-") ) )
( OutStd( hb_eol() ), OutStd( ReplAll(" d d  ", "-") ) )



PROCEDURE CriaPdf()

   LOCAL oPC, nTime, cDefaultPrinter, oPrinter, nEvent := 0

   if Empty( oPC := win_oleCreateObject( "PDFCreator.clsPDFCreator" ) )
      ( OutStd( hb_eol() ), OutStd( "Could not create PDFCreator COM object" ) )
      return
   endif


   oPC:__hSink := __axRegisterHandler( oPC:__hObj, {| X | nEvent := X } )

   oPC:cStart( "/NoProcessingAtStartup" )
   oPC:_cOption( "UseAutosave", 1 )
   oPC:_cOption( "UseAutosaveDirectory", 1 )
   oPC:_cOption( "AutosaveDirectory", hb_DirSepDel( hb_DirBase() ) )
   oPC:_cOption( "AutosaveFilename", "pdfcreat.pdf" )
   oPC:_cOption( "AutosaveFormat", 0 )

   cDefaultPrinter := oPC:cDefaultPrinter
   oPC:cDefaultPrinter := "PDFCreator"
   oPC:cClearCache()




   oPrinter := win_Prn():New( "PDFCreator" )
   oPrinter:Create()
   oPrinter:startDoc( "Harbour print job via PDFCreator" )
   oPrinter:NewLine()
   oPrinter:NewLine()
   oPrinter:TextOut( "Hello, PDFCreator! This is Harbour :)" )
   oPrinter:EndDoc()
   oPrinter:Destroy()






   oPC:cPrinterStop := .F.

   nTime := hb_MilliSeconds()
   while nEvent == 0 .AND. hb_MilliSeconds() - nTime < 10000
      hb_idleSleep( 0.5 )

      oPC:cOption( "UseAutosave" )
   ENDDO

   SWITCH nEvent
   CASE 0
      ( OutStd( hb_eol() ), OutStd( "Print timeout" ) )
      EXIT
   CASE 1
      ( OutStd( hb_eol() ), OutStd( "Printed successfully" ) )
      EXIT
   CASE 2
      ( OutStd( hb_eol() ), OutStd( "Error:", oPC:cError():Description ) )
      EXIT
   OTHERWISE
      ( OutStd( hb_eol() ), OutStd( "Unknown event" ) )
   ENDSWITCH

   oPC:cDefaultPrinter := cDefaultPrinter
   oPC:cClose()
   oPC := NIL

   return

PROC TESTE6()
cArq := "c:\SCI\TESTE.TXT"
LETO_SET( 17, "OFF" )
LETO_SET( 20, "PRINTER" )
Set( 24, (cArq), .F. )
LETO_SET( 23, "ON" )
( OutStd( hb_eol() ), OutStd( Time() ) )
LETO_SET( 23, "OFF" )
LETO_SET( 24, "" )
LETO_SET( 20, "SCREEN" )
LETO_SET( 17, "ON" )



ImprimeRaw( cArq )


FUNCTION ImprimeRaw(cArq)
LOCAL cPrinter:= WIN_PrinterGetDefault() , cMsg:="", nRet, nErro, cMensagem

      nRet:=WIN_PrintFileRaw(cPrinter,cArq,"Impressao Sistema")
      if nRet < 0
         cMsg := "Erro Imprimindo: "+hb_ntos(nRet)+" "
         SWITCH nRet
         CASE -1
            cMsg+="Parƒmetros inv lidos passados para fun‡„o."   ; EXIT
         CASE -2
            cMsg+="WinAPI OpenPrinter() falha na chamada."      ; EXIT
         CASE -3
            cMsg+="WinAPI StartDocPrinter() falha na chamada."  ; EXIT
         CASE -4
            cMsg+="WinAPI StartPagePrinter() falha na chamada." ; EXIT
         CASE -5
            cMsg+="WinAPI malloc() falha de mem¢ria."           ; EXIT
         CASE -6
            cMsg+="Arquivo " + cArq + " n„o localizado."        ; EXIT
         END
         nErro := wapi_GetLastError()
         cMensagem := space(128)
         wapi_FormatMessage(,,,,@cMensagem)






        Alert("N§ erro: "+hb_ntos(nErro)+ hb_eol()+ hb_eol()+ cMsg+ hb_eol()+ hb_eol()+ cMensagem)

      endif
return Nil



PROCEDURE Teste_Box()

   LOCAL i

   SetColor( "W/B" )
   Scroll() ; SetPos( 0, 0 )
   FOR i := 0 TO MaxRow()
      DevPos( i, 0 ) ; DevOut( Replicate( "@", MaxCol() + 1 ) )
   NEXT

   ft_XBox( , , , , , , , "This is a test", "of the ft_XBox() function" )


   ft_XBox( "L", "W", "D", "GR+/R", "W/B", 1, 10, "It is so nice",  "to not have to do the messy chore",  "of calculating the box size!" )



   ft_XBox( , "W", "D", "GR+/R", "W/B", MaxRow() - 8, 10, "It is so nice",  "to not have to do the messy chore",  "of calculating the box size!",  "Even though this line is way too long, and is in fact longer than the screen width, if you care to check!" )

   return
